================================================================================
CÓDIGO-FONTE DO PROJETO
================================================================================

SUMÁRIO
--------------------------------------------------------------------------------
Capítulo 1: .gitignore
Capítulo 2: backend\.env
Capítulo 3: backend\Dockerfile
Capítulo 4: backend\alembic.ini
Capítulo 5: backend\alembic\env.py
Capítulo 6: backend\alembic\versions\2d52dcb0afc1_create_agriculturalarea_selinux_fix.py
Capítulo 7: backend\alembic\versions\595de6c503ca_create_user_table.py
Capítulo 8: backend\app\api\deps.py
Capítulo 9: backend\app\api\v1\endpoints\auth.py
Capítulo 10: backend\app\api\v1\endpoints\users_admin.py
Capítulo 11: backend\app\core\config.py
Capítulo 12: backend\app\core\security.py
Capítulo 13: backend\app\crud\__init__.py
Capítulo 14: backend\app\crud\user.py
Capítulo 15: backend\app\db\base_class.py
Capítulo 16: backend\app\db\models\__init__.py
Capítulo 17: backend\app\db\models\agricultural_area.py
Capítulo 18: backend\app\db\models\user.py
Capítulo 19: backend\app\db\session.py
Capítulo 20: backend\app\main.py
Capítulo 21: backend\app\schemas\__init__.py
Capítulo 22: backend\app\schemas\token.py
Capítulo 23: backend\app\schemas\user.py
Capítulo 24: backend\entrypoint.sh
Capítulo 25: backend\htmlcov\.gitignore
Capítulo 26: backend\pytest.ini
Capítulo 27: backend\requirements.txt
Capítulo 28: backend\tests\api\v1\test_auth_endpoints.py
Capítulo 29: backend\tests\api\v1\test_users_admin_endpoints.py
Capítulo 30: backend\tests\conftest.py
Capítulo 31: backend\tests\core\test_security.py
Capítulo 32: backend\tests\crud\test_user_crud.py
Capítulo 33: backend\tests\schemas\test_token_schema.py
Capítulo 34: backend\tests\utils\user.py
Capítulo 35: docker-compose.yml
Capítulo 36: frontend\Dockerfile
Capítulo 37: frontend\env.d.ts
Capítulo 38: frontend\eslint.config.ts
Capítulo 39: frontend\package.json
Capítulo 40: frontend\src\App.vue
Capítulo 41: frontend\src\main.ts
Capítulo 42: frontend\src\router\index.ts
Capítulo 43: frontend\src\services\apiService.ts
Capítulo 44: frontend\src\stores\adminUsersStore.ts
Capítulo 45: frontend\src\stores\auth.ts
Capítulo 46: frontend\src\stores\counter.ts
Capítulo 47: frontend\src\types\token.ts
Capítulo 48: frontend\src\types\user.ts
Capítulo 49: frontend\src\views\AboutView.vue
Capítulo 50: frontend\src\views\ChangePasswordView.vue
Capítulo 51: frontend\src\views\HomeView.vue
Capítulo 52: frontend\src\views\LoginView.vue
Capítulo 53: frontend\src\views\RegisterView.vue
Capítulo 54: frontend\src\views\RequestPasswordRecoveryView.vue
Capítulo 55: frontend\src\views\ResetPasswordView.vue
Capítulo 56: frontend\src\views\UserProfileView.vue
Capítulo 57: frontend\src\views\admin\AdminCreateUserView.vue
Capítulo 58: frontend\src\views\admin\AdminEditUsersView.vue
Capítulo 59: frontend\src\views\admin\AdminUsersListView.vue
Capítulo 60: frontend\vite.config.ts


================================================================================
Capítulo 1: .gitignore
================================================================================

# Python (FastAPI)
__pycache__/
*.py[cod]
*.pyo
*.pyd
*.env
*.venv
env/
venv/
ENV/
*.sqlite3
*.db
instance/
*.log

# VSCode
.vscode/

# Node/Vue
node_modules/
dist/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
*.local

# OS
.DS_Store
Thumbs.db

# Others
*.bak
*.swp
.idea/

# Particular files
descriptive.py

================================================================================
Capítulo 2: backend\.env
================================================================================

# .env

SECRET_KEY=03RRXfZGfmUTPXjZlctCpvvP1Dw1VBeZ
RECOVERY_TOKEN_SECRET_KEY=R3c0v3r1fmUTPXT3St3CpvvP1Dw1VBeZ
DATABASE_URL=postgresql://agro_user:agro_password@db:5432/agro_db
SMTP_HOST=your.smtp.server.com
SMTP_PORT=587
SMTP_USER=your_email_username
SMTP_PASSWORD=your_email_password
EMAILS_FROM_EMAIL=noreply@yourdomain.com
SERVER_HOST=http://localhost:8000




================================================================================
Capítulo 3: backend\Dockerfile
================================================================================

# backend/Dockerfile

# =======================================================================================================
# --- Imagem Base ---                                                                               #####
# =======================================================================================================
FROM python:3.13-slim

# =======================================================================================================
# --- Variáveis de Ambiente ---                                                                     #####
# =======================================================================================================
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

# =======================================================================================================
# --- Diretório de Trabalho ---                                                                     #####
# =======================================================================================================
WORKDIR /app

# =======================================================================================================
# --- Instalação de Dependências Python ---                                                           #####
# =======================================================================================================
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# =======================================================================================================
# --- Copiando Código da Aplicação e Entrypoint ---                                                 #####
# =======================================================================================================
COPY entrypoint.sh /app/entrypoint.sh
RUN chmod +x /app/entrypoint.sh

COPY . .

# =======================================================================================================
# --- Exposição de Porta ---                                                                        #####
# =======================================================================================================
EXPOSE 8000

# =======================================================================================================
# --- Comando de Entrypoint ---                                                                     #####
# =======================================================================================================
ENTRYPOINT ["/app/entrypoint.sh"]


================================================================================
Capítulo 4: backend\alembic.ini
================================================================================

# A generic, single database configuration.

[alembic]
# path to migration scripts
# Use forward slashes (/) also on windows to provide an os agnostic path
script_location = alembic

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library and tzdata library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to alembic/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:alembic/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
# version_path_separator = newline
#
# Use os.pathsep. Default configuration used for new projects.
version_path_separator = os

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8

sqlalchemy.url = driver://user:pass@localhost/dbname


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = check --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S


================================================================================
Capítulo 5: backend\alembic\env.py
================================================================================

# /alembic/env.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from logging.config import fileConfig

from sqlalchemy import create_engine 
from sqlalchemy import pool
from sqlalchemy.dialects import postgresql

from alembic import context

import os
import sys

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from app.core.config import settings
from app.db.base_class import Base

from app.db.models.user import User
from app.db.models.agricultural_area import AgriculturalArea


# =======================================================================================================
# --- Configurações ---                                                                             #####
# =======================================================================================================

_ = User
_ = AgriculturalArea

config = context.config

if config.config_file_name is not None:
    fileConfig(config.config_file_name)

config.set_main_option('sqlalchemy.url', settings.DATABASE_URL)

target_metadata = Base.metadata

# =======================================================================================================
# --- Funções de Migração ---                                                                       #####
# =======================================================================================================

def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = str(settings.DATABASE_URL)
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = create_engine(str(settings.DATABASE_URL), poolclass=pool.NullPool)

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
            compare_type=True
        )

        with context.begin_transaction():
            context.run_migrations()

# =======================================================================================================
# --- Condição de Migração ---                                                                      #####
# =======================================================================================================

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()


================================================================================
Capítulo 6: backend\alembic\versions\2d52dcb0afc1_create_agriculturalarea_selinux_fix.py
================================================================================

"""create_agriculturalarea_selinux_fix

Revision ID: 2d52dcb0afc1
Revises: 595de6c503ca
Create Date: 2025-06-01 01:06:58.286576

"""

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================


from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
import geoalchemy2

# =======================================================================================================
# --- Revisão e Identificadores ---                                                                 #####
# =======================================================================================================

revision: str = '2d52dcb0afc1'
down_revision: Union[str, None] = '595de6c503ca'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

# =======================================================================================================
# --- Upgrade e Downgrade do Alembic ---                                                            #####
# =======================================================================================================

def upgrade() -> None:
    op.create_table('agriculturalarea',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=255), nullable=False),
    sa.Column('description', sa.String(), nullable=True),
    sa.Column('geometry', geoalchemy2.types.Geometry(geometry_type='POLYGON', srid=4326, from_text='ST_GeomFromEWKT', name='geometry'), nullable=False),  # pyright: ignore[reportUnknownArgumentType]
    sa.Column('area_hectares', sa.Float(), nullable=True),
    sa.Column('user_id', sa.Integer(), nullable=False),
    sa.Column('created_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.Column('updated_at', sa.DateTime(), server_default=sa.text('now()'), nullable=False),
    sa.ForeignKeyConstraint(['user_id'], ['user.id'], name=op.f('fk_agriculturalarea_user_id_user')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_agriculturalarea'))
    )
    op.create_index(op.f('ix_agriculturalarea_id'), 'agriculturalarea', ['id'], unique=False)
    op.create_index(op.f('ix_agriculturalarea_name'), 'agriculturalarea', ['name'], unique=False)

def downgrade() -> None:
    op.drop_index(op.f('ix_agriculturalarea_name'), table_name='agriculturalarea')
    op.drop_index(op.f('ix_agriculturalarea_id'), table_name='agriculturalarea')
    op.drop_table('agriculturalarea')

================================================================================
Capítulo 7: backend\alembic\versions\595de6c503ca_create_user_table.py
================================================================================

"""create_user_table

Revision ID: 595de6c503ca
Revises: 
Create Date: 2025-05-20 13:58:34.664170

"""

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# =======================================================================================================
# --- Revisão e Identificadores ---                                                                 #####
# =======================================================================================================

revision: str = '595de6c503ca'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

# =======================================================================================================
# --- Upgrade e Downgrade do Alembic ---                                                            #####
# =======================================================================================================

def upgrade() -> None:
    """Upgrade schema."""
    op.create_table('user',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('email', sa.String(length=255), nullable=False),
    sa.Column('hashed_password', sa.String(length=255), nullable=False),
    sa.Column('full_name', sa.String(length=255), nullable=True),
    sa.Column('is_active', sa.Boolean(), nullable=False),
    sa.Column('is_superuser', sa.Boolean(), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_user_email'), 'user', ['email'], unique=True)
    op.create_index(op.f('ix_user_full_name'), 'user', ['full_name'], unique=False)
    op.create_index(op.f('ix_user_id'), 'user', ['id'], unique=False)


def downgrade() -> None:
    """Downgrade schema."""
    op.drop_index(op.f('ix_user_id'), table_name='user')
    op.drop_index(op.f('ix_user_full_name'), table_name='user')
    op.drop_index(op.f('ix_user_email'), table_name='user')
    op.drop_table('user')


================================================================================
Capítulo 8: backend\app\api\deps.py
================================================================================

# app/api/deps.py

# ====================================================================================
# --- Importações ---                                                            =====
# ====================================================================================

from typing import Generator

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError
from pydantic import ValidationError
from sqlalchemy.orm import Session

from app.db.session import SessionLocal
from app.core import security
from app.core.config import settings
from app.db.models.user import User as UserModel 
from app.schemas.token import TokenData
from app.crud import user as crud_user 

# ====================================================================================
# --- Autenticação ---                                                           =====
# ====================================================================================

reusable_oauth2 = OAuth2PasswordBearer(
    tokenUrl=f"{settings.API_V1_STR}/auth/login" #
)

# ====================================================================================
# --- Funções ---                                                                =====
# ====================================================================================

def get_db() -> Generator[Session, None, None]: # pragma: no cover
    """
    Dependência para obter uma sessão do banco de dados por request.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


async def get_current_user(
    db: Session = Depends(get_db), token: str = Depends(reusable_oauth2)
) -> UserModel:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = security.decode_token(token)
        if payload is None:
            raise credentials_exception
        
        token_email_from_payload = payload.get("sub")
        if token_email_from_payload is None:
            raise credentials_exception
        
        token_data = TokenData(email=token_email_from_payload)

    except (JWTError, ValidationError):
        raise credentials_exception

    if token_data.email is None: 
        raise credentials_exception # pragma: no cover

    user = crud_user.get_user_by_email(db, email=token_data.email)
    
    if user is None:
        raise credentials_exception
    return user


async def get_current_active_user(
    current_user: UserModel = Depends(get_current_user),
) -> UserModel:
    """
    Dependência para obter o usuário atual que também está ativo.
    """
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    return current_user


async def get_current_active_superuser(
    current_user: UserModel = Depends(get_current_active_user),
) -> UserModel:
    """
    Dependência para obter o usuário atual que é ativo e superusuário.
    """
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="The user doesn't have enough privileges",
        )
    return current_user

================================================================================
Capítulo 9: backend\app\api\v1\endpoints\auth.py
================================================================================

# app/api/v1/endpoints/auth.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from typing import Any, Dict

from fastapi import APIRouter, Body, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm 
from sqlalchemy.orm import Session

from app.schemas.user import ( 
    UserCreate,
    UserRead,
    UserUpdate,
    UserPasswordChange,
    PasswordRecoveryRequest, 
    PasswordResetForm        
)
from app.schemas.token import Token
from app.crud.user import ( 
    get_user_by_email,
    create_user,
    update_user,
    delete_user 
)
from app.api import deps
from app.core import security
from app.core.config import settings
from app.db.models.user import User as UserModel 

# =======================================================================================================
# --- Rotas ---                                                                                     #####
# =======================================================================================================

router = APIRouter()

# =======================================================================================================
# --- Endpoints ---                                                                                 #####
# =======================================================================================================

@router.post("/register", response_model=UserRead, status_code=status.HTTP_201_CREATED)
def register_new_user(
    *,
    db: Session = Depends(deps.get_db),
    user_in: UserCreate,
) -> Any:
    """
    Cria um novo usuário.
    """
    user = get_user_by_email(db, email=user_in.email)
    if user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="The user with this email already exists in the system.",
        )
    new_user = create_user(db=db, user=user_in)
    return new_user


@router.post("/login", response_model=Token)
def login_for_access_token(
    db: Session = Depends(deps.get_db),
    form_data: OAuth2PasswordRequestForm = Depends() 
) -> Any:
    """
    OAuth2 compatível com endpoint de token, login com email e senha.
    Retorna um access_token e um refresh_token (opcional).
    """
    user = get_user_by_email(db, email=form_data.username)
    if not user or not security.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if not user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    
    access_token = security.create_access_token(
        data={"sub": user.email} 
    )
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
    }


@router.get("/me", response_model=UserRead)
def read_users_me(
    current_user: UserModel = Depends(deps.get_current_active_user),
) -> Any:
    """
    Obtém o usuário atual.
    """
    return current_user


@router.get("/me/superuser", response_model=UserRead)
def read_current_superuser(
    current_user: UserModel = Depends(deps.get_current_active_superuser),
) -> Any:
    """
    Obtém o usuário atual, requerendo que seja um superusuário ativo.
    Endpoint de teste para a dependência get_current_active_superuser.
    """
    return current_user


@router.patch("/me", response_model=UserRead)
def update_user_me(
    *,
    db: Session = Depends(deps.get_db),
    user_update_data: UserUpdate, 
    current_user: UserModel = Depends(deps.get_current_active_user) 
) -> Any:
    """
    Atualiza os dados do usuário autenticado.
    Permite atualizar email, full_name, password (se enviado).
    Campos como is_active e is_superuser não devem ser atualizáveis pelo próprio usuário aqui.
    """
    if user_update_data.email and user_update_data.email != current_user.email:
        existing_user = get_user_by_email(db, email=user_update_data.email)
        if existing_user and existing_user.id != current_user.id:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered by another user.",
            )

    update_data_for_crud = user_update_data.model_dump(exclude_unset=True)
    if "is_active" in update_data_for_crud:
        del update_data_for_crud["is_active"] 
    if "is_superuser" in update_data_for_crud:
        del update_data_for_crud["is_superuser"] 

    updated_user = update_user(db=db, db_user=current_user, user_in=update_data_for_crud)
    return updated_user


@router.put("/me/password", status_code=status.HTTP_204_NO_CONTENT)
def update_current_user_password(
    *,
    db: Session = Depends(deps.get_db),
    password_data: UserPasswordChange, 
    current_user: UserModel = Depends(deps.get_current_active_user)
) -> None: 
    """
    Atualiza a senha do usuário autenticado.
    Requer a senha atual e a nova senha (com confirmação).
    """
    # 1. Verificar se a senha atual fornecida está correta
    if not security.verify_password(password_data.current_password, current_user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Incorrect current password",
        )
    
    # 2. Verificar se a nova senha é diferente da antiga 
    if security.verify_password(password_data.new_password, current_user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="New password cannot be the same as the current password.",
        )

    # 3. Gerar o hash da nova senha
    hashed_password = security.get_password_hash(password_data.new_password)
    current_user.hashed_password = hashed_password 
    
    db.add(current_user)
    db.commit()


@router.delete("/me", status_code=status.HTTP_204_NO_CONTENT)
def delete_user_me(
    *,
    db: Session = Depends(deps.get_db),
    current_user: UserModel = Depends(deps.get_current_active_user)
) -> None: 
    """
    Deleta a conta do usuário autenticado.
    """
    delete_user(db=db, db_user=current_user)
    return None


@router.post("/password-recovery", response_model=Dict[str, str])
async def request_password_recovery(
    recovery_data: PasswordRecoveryRequest,
    db: Session = Depends(deps.get_db)
) -> Any:
    """
    Inicia o processo de recuperação de senha.
    Gera um token de recuperação se o usuário existir.
    (Simula o envio de e-mail printando o token e um link de exemplo).
    """
    user = get_user_by_email(db, email=recovery_data.email)
    if not user:
        return {"message": "Se um usuário com este email existir, um link de recuperação foi enviado."}

    password_reset_token = security.create_password_reset_token(email=user.email)
    
    reset_link = f"{settings.SERVER_HOST}{settings.API_V1_STR}/auth/reset-password-form?token={password_reset_token}" 
    
    print("---- SIMULAÇÃO DE ENVIO DE E-MAIL ----")
    print(f"Para: {user.email}")
    print(f"Assunto: Recuperação de Senha - {settings.PROJECT_NAME}")
    print(f"Use o seguinte token para resetar sua senha (ou clique no link): {password_reset_token}")
    print(f"Ou acesse o link: {reset_link}")
    print("--------------------------------------")
    
    return {"message": "Se um usuário com este email existir, um link de recuperação foi enviado."}


@router.post("/reset-password", status_code=status.HTTP_204_NO_CONTENT)
async def reset_user_password(
    reset_form_data: PasswordResetForm = Body(...),
    db: Session = Depends(deps.get_db)
) -> None:
    """
    Reseta a senha do usuário usando um token de recuperação válido.
    """
    email_from_token = security.verify_password_reset_token(reset_form_data.token)
    if not email_from_token:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Token de recuperação de senha inválido ou expirado.",
        )
    
    user = get_user_by_email(db, email=email_from_token)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Usuário não encontrado. Token pode ser inválido.",
        )
    
    if not user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Usuário inativo.")
    
    hashed_password = security.get_password_hash(reset_form_data.new_password)
    user.hashed_password = hashed_password
    db.add(user)
    db.commit()

    # Simulação de envio de e-mail de confirmação:
    print(f"---- SIMULAÇÃO DE ENVIO DE E-MAIL ----")         
    print(f"Para: {user.email}")                            
    print(f"Assunto: Sua senha foi alterada - {settings.PROJECT_NAME}")
    print(f"Sua senha foi alterada com sucesso.")              
    print("--------------------------------------") 

    return None

================================================================================
Capítulo 10: backend\app\api\v1\endpoints\users_admin.py
================================================================================

# backend/app/api/v1/endpoints/users_admin.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from typing import Any, List

from fastapi import APIRouter,Depends, HTTPException, Query, status
from sqlalchemy.orm import Session

from app.api import deps
from app.crud import user as crud_user
from app.db.models.user import User as UserModel
from app.schemas.user import UserCreate, UserRead, UserUpdate


# =======================================================================================================
# --- Rotas ---                                                                                     #####
# =======================================================================================================

router = APIRouter()

# =======================================================================================================
# --- Endpoints (Administração de Usuários) ---                                                     #####
# =======================================================================================================

@router.get("/", response_model=List[UserRead], status_code=status.HTTP_200_OK)
def read_users(
    db: Session = Depends(deps.get_db),
    skip: int = Query(0, ge=0, description="Número de registros a pular para paginação"),
    limit: int = Query(100, ge=1, le=200, description="Número máximo de registros a retornar"),
    current_admin: UserModel = Depends(deps.get_current_active_superuser),
) -> Any:
    """
    Recupera uma lista de usuários.
    Acessível apenas por superusuários.
    """
    users = crud_user.get_users(db, skip=skip, limit=limit)
    return users


@router.post("/", response_model=UserRead, status_code=status.HTTP_201_CREATED)
def create_user_by_admin_endpoint(
    *,
    db: Session = Depends(deps.get_db),
    user_in: UserCreate,
    current_admin: UserModel = Depends(deps.get_current_active_superuser),
) -> Any:
    """
    Cria um novo usuário no sistema.
    Acessível apenas por superusuários. Permite definir todos os campos, incluindo is_active e is_superuser.
    """
    user = crud_user.get_user_by_email(db, email=user_in.email)
    if user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="O usuário com este email já existe no sistema.",
        )
    new_user = crud_user.create_user_by_admin(db=db, user=user_in)
    return new_user


@router.get("/{user_id}", response_model=UserRead, status_code=status.HTTP_200_OK)
def read_user_by_id_admin(
    user_id: int,
    db: Session = Depends(deps.get_db),
    current_admin: UserModel = Depends(deps.get_current_active_superuser),
) -> Any:
    """
    Obtém um usuário específico pelo ID.
    Acessível apenas por superusuários.
    """
    user = crud_user.get_user(db, user_id=user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="O usuário com este ID não foi encontrado no sistema.",
        )
    return user


@router.put("/{user_id}", response_model=UserRead, status_code=status.HTTP_200_OK)
def update_user_by_admin_endpoint(
    *,
    db: Session = Depends(deps.get_db),
    user_id: int,
    user_in: UserUpdate,
    current_admin: UserModel = Depends(deps.get_current_active_superuser),
) -> Any:
    """
    Atualiza um usuário existente pelo ID.
    Acessível apenas por superusuários. Permite atualizar todos os campos editáveis,
    incluindo is_active, is_superuser e, opcionalmente, a senha.
    """
    user = crud_user.get_user(db, user_id=user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="O usuário com este ID não foi encontrado no sistema.",
        )

    if user_in.email and user_in.email != user.email:
        existing_user_with_new_email = crud_user.get_user_by_email(db, email=user_in.email)
        if existing_user_with_new_email:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="O novo email fornecido já está registrado por outro usuário.",
            )

    updated_user = crud_user.update_user(db=db, db_user=user, user_in=user_in)
    return updated_user


@router.delete("/{user_id}", response_model=UserRead, status_code=status.HTTP_200_OK)
def delete_user_by_admin_endpoint(
    *,
    db: Session = Depends(deps.get_db),
    user_id: int,
    current_admin: UserModel = Depends(deps.get_current_active_superuser),
) -> Any:
    """
    Deleta um usuário específico pelo ID.
    Acessível apenas por superusuários.
    Não permite que um superusuário delete a si mesmo através deste endpoint.
    """
    if current_admin.id == user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Superusuários não podem deletar a si mesmos através deste endpoint. Use /auth/me.",
        )

    user_to_delete = crud_user.get_user(db, user_id=user_id)
    if not user_to_delete:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="O usuário com este ID não foi encontrado no sistema para deleção.",
        )

    deleted_user = crud_user.delete_user(db=db, db_user=user_to_delete)
    return deleted_user

================================================================================
Capítulo 11: backend\app\core\config.py
================================================================================

# app/core/config.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from typing import Optional
from pydantic import EmailStr
from pydantic_settings import BaseSettings, SettingsConfigDict 
from dotenv import load_dotenv


# =======================================================================================================
# --- Carrega Variáveis de Ambiente ---                                                             #####
# =======================================================================================================

load_dotenv()

# =======================================================================================================
# --- Configurações ---                                                                             #####
# =======================================================================================================

class Settings(BaseSettings):
    PROJECT_NAME: str = "CRUD-Template"
    API_V1_STR: str = "/api/v1"

    # Configurações do Banco de Dados
    DATABASE_URL: str = "postgresql://default_user:default_password@localhost:5432/default_db"
    DATABASE_URL_TEST: Optional[str] = None

    # Configurações para JWT 
    SECRET_KEY: str = "a_very_secret_key_that_should_be_long_and_random_and_changed"
    RECOVERY_TOKEN_SECRET_KEY: str = "a_very_secret_key_that_should_be_long_and_random_and_changed"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7  

    # Configurações de tipo
    FIRST_SUPERUSER_EMAIL: EmailStr = "admin@example.com"
    FIRST_SUPERUSER_PASSWORD: str = "changethis"

    # Configurações para Token de Recuperação de Senha
    PASSWORD_RESET_TOKEN_EXPIRE_HOURS: int = 1
    SERVER_HOST: str = "http://localhost:8000"

    # Configurações para Email
    SMTP_TLS: bool = True
    SMTP_PORT: Optional[int] = None
    SMTP_HOST: Optional[str] = None
    SMTP_USER: Optional[str] = None
    SMTP_PASSWORD: Optional[str] = None
    EMAILS_FROM_EMAIL: Optional[EmailStr] = None
    EMAILS_FROM_NAME: Optional[str] = None

    # Configurações de Ambiente
    model_config = SettingsConfigDict(
        env_file=".env",        
        env_file_encoding='utf-8',
        case_sensitive=True,
        extra='ignore'          
    )

settings = Settings()

================================================================================
Capítulo 12: backend\app\core\security.py
================================================================================

# app/core/security.py


# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from datetime import datetime, timedelta, timezone
from typing import Optional, Any, Dict

from jose import JWTError, jwt
from passlib.context import CryptContext

from app.core.config import settings


# =======================================================================================================
# --- Configuração do Passlib para hashing de senhas ---                                            #####
# =======================================================================================================

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

ALGORITHM = settings.ALGORITHM
SECRET_KEY = settings.SECRET_KEY
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES
REFRESH_TOKEN_EXPIRE_DAYS = settings.REFRESH_TOKEN_EXPIRE_DAYS
PASSWORD_RESET_TOKEN_EXPIRE_HOURS = settings.PASSWORD_RESET_TOKEN_EXPIRE_HOURS

# =======================================================================================================
# --- Funções ---                                                                                   #####
# =======================================================================================================

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifica se a senha plana corresponde à senha com hash."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Gera o hash de uma senha."""
    return pwd_context.hash(password)

def create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def create_refresh_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:
    """Cria um novo refresh token JWT."""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def create_password_reset_token(email: str) -> str:
    """
    Gera um token JWT específico para recuperação de senha.
    O 'sub' do token será o email. Adiciona 'type' claim.
    """
    expire = datetime.now(timezone.utc) + timedelta(hours=PASSWORD_RESET_TOKEN_EXPIRE_HOURS)
    to_encode: Dict[str, Any] = {
        "exp": expire,
        "sub": email,
        "type": "password_reset" 
    }
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_password_reset_token(token: str) -> Optional[str]:
    """
    Verifica um token de recuperação de senha.
    Retorna o email (subject) se o token for válido e do tipo 'password_reset',
    caso contrário, retorna None.
    """
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[ALGORITHM])
        if payload.get("type") == "password_reset":
            email_sub = payload.get("sub")
            if isinstance(email_sub, str): 
                 return email_sub
        return None # pragma: no cover
    except JWTError: 
        return None

def decode_token(token: str) -> Optional[dict[str, Any]]:
    """Decodifica um token JWT e retorna o payload se válido, None caso contrário."""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None

def get_subject_from_token(token: str) -> Optional[str]:
    """
    Decodifica um token JWT e extrai o 'sub' (subject, e.g., email ou user_id) do payload.
    Retorna o subject se o token for válido e o subject estiver presente, caso contrário None.
    """
    payload = decode_token(token)
    if payload:
        return payload.get("sub")
    return None

================================================================================
Capítulo 13: backend\app\crud\__init__.py
================================================================================

# app/crud/__init__.py
from .user import get_user, get_user_by_email, create_user, update_user, delete_user

__all__ = [
    "get_user",
    "get_user_by_email",
    "create_user",
    "update_user", 
    "delete_user",
]

================================================================================
Capítulo 14: backend\app\crud\user.py
================================================================================

# app/crud/user.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from typing import Any, Dict, List, Optional, Union
from sqlalchemy.orm import Session

from app.db.models.user import User as UserModel
from app.schemas.user import UserCreate, UserUpdate
from app.core.security import get_password_hash

# =======================================================================================================
# --- CRUD ---                                                                                      #####
# =======================================================================================================

def get_user_by_email(db: Session, email: str) -> Optional[UserModel]: 
    """
    Busca um usuário pelo seu endereço de e-mail.
    """
    return db.query(UserModel).filter(UserModel.email == email).first()

def get_user(db: Session, user_id: int) -> Optional[UserModel]: 
    """
    Busca um usuário pelo seu ID.
    """
    return db.query(UserModel).filter(UserModel.id == user_id).first()

# =======================================================================================================
# --- CRUD (Superuser) ---                                                                          #####
# =======================================================================================================

def get_users(db: Session, skip: int = 0, limit: int = 100) -> List[UserModel]:
    """
    Busca todos os usuários com paginação.
    Acessível apenas por superusuários.
    """
    return db.query(UserModel).offset(skip).limit(limit).all()

def create_user_by_admin(db: Session, user: UserCreate) -> UserModel: 
    """
    Cria um novo usuário no banco de dados (ação de administrador).
    Permite definir is_active e is_superuser.
    """
    hashed_password = get_password_hash(user.password)
    db_user = UserModel(
        email=user.email,
        hashed_password=hashed_password,
        full_name=user.full_name,
        is_active=user.is_active,
        is_superuser=user.is_superuser 
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

# =======================================================================================================
# --- CRUD (Usuário Comum / Superuser) ---                                                          #####
# =======================================================================================================

def create_user(db: Session, user: UserCreate) -> UserModel:
    """
    Cria um novo usuário no banco de dados.
    """
    hashed_password = get_password_hash(user.password)
    db_user = UserModel(
        email=user.email,
        hashed_password=hashed_password,
        full_name=user.full_name,
        is_active=user.is_active if user.is_active is not None else True,
        is_superuser=user.is_superuser if user.is_superuser is not None else False
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def update_user(
    db: Session,
    db_user: UserModel, 
    user_in: Union[UserUpdate, Dict[str, Any]]
) -> UserModel:
    """
    Atualiza um usuário no banco de dados.
    Se user_in for UserUpdate, pode ser um usuário atualizando o próprio perfil.
    Se user_in for Dict (usado por admin), pode atualizar is_active, is_superuser.
    """
    if isinstance(user_in, dict):
        update_data = user_in
    else:
        update_data = user_in.model_dump(exclude_unset=True)

    if update_data.get("password"): 
        hashed_password = get_password_hash(update_data["password"])
        db_user.hashed_password = hashed_password
        if "password" in update_data : del update_data["password"] 

    for field, value in update_data.items():
        if hasattr(db_user, field): 
            if value is not None or (field in ["full_name"] and isinstance(user_in, UserUpdate)):
                 setattr(db_user, field, value)


    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def delete_user(db: Session, db_user: UserModel) -> UserModel:
    """
    Deleta um usuário do banco de dados.
    """
    db.delete(db_user)
    db.commit()
    return db_user 

================================================================================
Capítulo 15: backend\app\db\base_class.py
================================================================================

# app/db/base_class.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from sqlalchemy.orm import DeclarativeBase, declared_attr
from typing import Any

# =======================================================================================================
# --- Instância ---                                                                                 #####
# =======================================================================================================
class Base(DeclarativeBase):
    """
    Classe base para os modelos SQLAlchemy.
    Automaticamente define o nome da tabela como o nome da classe em minúsculas.
    """
    id: Any
    __name__: str

    @declared_attr.directive
    def __tablename__(cls) -> str:
        return cls.__name__.lower()

================================================================================
Capítulo 16: backend\app\db\models\__init__.py
================================================================================

# app/db/models/__init__.py

from .user import User
from .agricultural_area import AgriculturalArea

__all__ = ["User", "AgriculturalArea"]

_ = User
_ = AgriculturalArea


================================================================================
Capítulo 17: backend\app\db\models\agricultural_area.py
================================================================================

# app/db/models/agricultural_area.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from sqlalchemy import Integer, String, Float, ForeignKey, DateTime, func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from geoalchemy2 import Geometry

from app.db.base_class import Base
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .user import User

# =======================================================================================================
# --- Classe Base de Usuário ---                                                                    #####
# =======================================================================================================

class AgriculturalArea(Base):
    """
    Modelo de tabela para áreas agrícolas.
    Esta tabela armazena informações sobre áreas agrícolas, incluindo geometria, área em hectares,
    e a relação com o usuário proprietário.
    """
    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    name: Mapped[str] = mapped_column(String(255), index=True, nullable=False)
    description: Mapped[str | None] = mapped_column(String, nullable=True)
    
    geometry: Mapped[Geometry] = mapped_column(
        Geometry(geometry_type='POLYGON', srid=4326, spatial_index=True, from_text='ST_GeomFromEWKT', name='geometry'),
        nullable=False
    )

    area_hectares: Mapped[float | None] = mapped_column(Float, nullable=True)
    
    user_id: Mapped[int] = mapped_column(Integer, ForeignKey("user.id"), nullable=False)
    owner: Mapped["User"] = relationship(back_populates="agricultural_areas")

    created_at: Mapped[DateTime] = mapped_column(DateTime, default=func.now(), nullable=False)
    updated_at: Mapped[DateTime] = mapped_column(DateTime, default=func.now(), onupdate=func.now(), nullable=False)

================================================================================
Capítulo 18: backend\app\db\models\user.py
================================================================================

# app/db/models/user.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from sqlalchemy import Integer, String, Boolean
from sqlalchemy.orm import Mapped, mapped_column, relationship
from typing import List, TYPE_CHECKING

from app.db.base_class import Base 

if TYPE_CHECKING:
    from .agricultural_area import AgriculturalArea

# =======================================================================================================
# --- Classe Base de Usuário ---                                                                    #####
# =======================================================================================================
class User(Base):
    """
    Modelo de tabela para os usuários.
    Esta tabela armazena informações sobre os usuários, incluindo email, senha,
    nome completo, status de atividade e permissões de superusuário.
    Relaciona-se com a tabela de áreas agrícolas, permitindo que um usuário possua várias áreas.
    A tabela também define o relacionamento com a tabela de áreas agrícolas,
    permitindo operações de cascata como exclusão em massa.
    """

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True, nullable=False)
    hashed_password: Mapped[str] = mapped_column(String(255), nullable=False)
    full_name: Mapped[str | None] = mapped_column(String(255), index=True, nullable=True) 
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    is_superuser: Mapped[bool] = mapped_column(Boolean, default=False)
    agricultural_areas: Mapped[List["AgriculturalArea"]] = relationship(
        "AgriculturalArea", back_populates="owner", cascade="all, delete-orphan")


================================================================================
Capítulo 19: backend\app\db\session.py
================================================================================

# app/db/session.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from typing import Generator

from app.core.config import settings


# =======================================================================================================
# --- Motor e Seção local ---                                                                       #####
# =======================================================================================================

engine = create_engine(settings.DATABASE_URL, pool_pre_ping=True)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# =======================================================================================================
# --- Dependência ---                                                                               #####
# =======================================================================================================

def get_db() -> Generator[Session, None, None]: # pragma: no cover
    """
    Função de dependência para obter uma sessão do banco de dados por request.
    Garante que a sessão seja fechada após o request, mesmo em caso de erro.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

================================================================================
Capítulo 20: backend\app\main.py
================================================================================

# app/main.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from fastapi import FastAPI
from typing import Dict
from fastapi.middleware.cors import CORSMiddleware 

from app.core.config import settings
from app.api.v1.endpoints import auth as auth_router
from app.api.v1.endpoints import users_admin as users_admin_router


# =======================================================================================================
# --- Instância ---                                                                                 #####
# =======================================================================================================

app = FastAPI(
    title=settings.PROJECT_NAME,
    version="0.1.0",
    description="FastAPI Template para CRUD",
    openapi_url=f"{settings.API_V1_STR}/openapi.json"
)

# =======================================================================================================
# --- Configuração CORS ---                                                                         ##### 
# =======================================================================================================

origins = [
    "http://localhost",         
    "http://localhost:8080",    
    "http://localhost:5173",
    "http://localhost:5174",    
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,  
    allow_credentials=True, 
    allow_methods=["*"],    
    allow_headers=["*"],    
)

# =======================================================================================================
# --- Rotas ---                                                                                     #####
# =======================================================================================================

app.include_router(auth_router.router, prefix=settings.API_V1_STR + "/auth", tags=["Authentication & Users"])
app.include_router(users_admin_router.router, prefix=settings.API_V1_STR + "/users", tags=["Admin - Users Management"]) 

# =======================================================================================================
# --- Endpoints ---                                                                                 #####
# =======================================================================================================

@app.get("/", tags=["Root"])
async def read_root() -> Dict[str, str]:
    """
    Endpoint raiz da aplicação.
    Retorna uma mensagem de boas-vindas.
    """
    return {"message": f"Bem-vindo à API: {settings.PROJECT_NAME}!"}

@app.get("/health", tags=["Health Check"])
async def health_check() -> Dict[str, str]:
    """
    Endpoint de verificação de saúde.
    Útil para K8s, Docker Swarm, etc.
    """
    return {"status": "ok"}


================================================================================
Capítulo 21: backend\app\schemas\__init__.py
================================================================================

# app/schemas/__init__.py

from .user import (
    UserBase,
    UserCreate,
    UserUpdate,
    UserRead,
    UserInDB,
    UserPasswordChange,
    PasswordRecoveryRequest,
    PasswordResetForm,
)
from .token import Token, TokenData

__all__ = [
    "UserBase",
    "UserCreate",
    "UserUpdate",
    "UserRead",
    "UserInDB",
    "UserPasswordChange",
    "PasswordRecoveryRequest",
    "PasswordResetForm",
    "Token",
    "TokenData",
]

================================================================================
Capítulo 22: backend\app\schemas\token.py
================================================================================

# app/schemas/token.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from typing import Optional
from pydantic import BaseModel, EmailStr

# =======================================================================================================
# --- Token Base e Data ---                                                                         #####
# =======================================================================================================

class Token(BaseModel):
    access_token: str
    token_type: str
    refresh_token: Optional[str] = None

class TokenData(BaseModel):
    email: Optional[EmailStr] = None


================================================================================
Capítulo 23: backend\app\schemas\user.py
================================================================================

# app/schemas/user.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from pydantic import BaseModel, ConfigDict, EmailStr, Field, field_validator, ValidationInfo
from typing import Optional

# =======================================================================================================
# --- Schemas de Usuário ---                                                                        #####
# =======================================================================================================

class UserBase(BaseModel):
    full_name: Optional[str] = None
    is_active: Optional[bool] = Field(default=True)
    is_superuser: Optional[bool] = Field(default=False)

class UserCreate(BaseModel): 
    """Schema para criar um novo usuário."""
    email: EmailStr 
    password: str   
    full_name: Optional[str] = None
    is_active: Optional[bool] = Field(default=True) 
    is_superuser: Optional[bool] = Field(default=False)

class UserUpdate(UserBase):
    """Schema para atualizar um usuário. Todos os campos são opcionais."""
    email: Optional[EmailStr] = None
    password: Optional[str] = None 

class UserRead(BaseModel):
    """Schema para dados de usuário retornados pela API."""
    id: int
    email: EmailStr
    full_name: Optional[str] = None
    is_active: bool
    is_superuser: bool
    model_config = ConfigDict(from_attributes=True)

class UserInDB(UserRead):
    hashed_password: str

class UserPasswordChange(BaseModel):
    """Schema para mudança de senha do usuário."""
    current_password: str
    new_password: str
    new_password_confirm: str

    @field_validator('new_password_confirm')
    @classmethod
    def passwords_match(cls, v: str, info: ValidationInfo) -> str:
        """Verifica se a nova senha e a confirmação correspondem."""
        if info.data and 'new_password' in info.data and v != info.data['new_password']:
            raise ValueError('As senhas não correspondem')
        return v
    
class PasswordRecoveryRequest(BaseModel):
    """Schema para solicitar a recuperação de senha."""
    email: EmailStr

class PasswordResetForm(BaseModel):
    """
    Schema para o formulário de reset (definição) de nova senha.
    Utilizado quando o usuário já tem o token de recuperação.
    """
    token: str 
    new_password: str
    new_password_confirm: str

    @field_validator('new_password_confirm')
    @classmethod
    def passwords_match(cls, v: str, info: ValidationInfo) -> str:
        """Verifica se a nova senha e a confirmação correspondem."""
        if info.data and 'new_password' in info.data and v != info.data['new_password']:
            raise ValueError('As senhas não correspondem')
        return v

================================================================================
Capítulo 24: backend\entrypoint.sh
================================================================================

#!/bin/sh

# =======================================================================================================
# --- Script de Entrypoint para o Backend ---                                                       #####
# =======================================================================================================

# Este script é executado quando o container do backend é iniciado.
# Ele é responsável por aplicar as migrações do banco de dados e iniciar o servidor da aplicação.

# =======================================================================================================
# --- Aplicar Migrações do Banco de Dados ---                                                       #####
# =======================================================================================================
echo "Applying database migrations..."
alembic upgrade head

# =======================================================================================================
# --- Iniciar Servidor da Aplicação ---                                                             #####
# =======================================================================================================
echo "Starting server..."
exec uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload


================================================================================
Capítulo 25: backend\htmlcov\.gitignore
================================================================================

# Created by coverage.py
*


================================================================================
Capítulo 26: backend\pytest.ini
================================================================================

# pytest.ini
[pytest]
minversion = 6.0
addopts = -ra -q --cov=app --cov-report=term-missing --cov-report=html
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*

filterwarnings =
    ignore:.*'crypt' is deprecated and slated for removal in Python 3.13:DeprecationWarning:passlib.utils.*

================================================================================
Capítulo 27: backend\requirements.txt
================================================================================

alembic>=1.11.0,<1.13
email-validator>=1.1,<2.1
factory-boy>=3.2.0,<4.0
fastapi>=0.100.0,<1.0.0
freezegun>=1.1.0,<2.0
geoalchemy2>=0.14,<0.15
httpx>=0.23.0,<1.0
passlib[bcrypt]>=1.7.4,<2.0
psycopg2-binary>=2.9.0,<3.0
pydantic>=2.5.3,<3.0
pydantic-settings>=2.2.1,<3.0
pytest>=7.0.0,<9.0
pytest-cov>=3.0.0,<5.0
python-dotenv>=1.0.0,<2.0
python-jose[cryptography]>=3.3.0,<4.0
python-multipart>=0.0.5,<1.0
sqlalchemy>=2.0.0,<3.0
uvicorn[standard]>=0.23.0,<1.0


================================================================================
Capítulo 28: backend\tests\api\v1\test_auth_endpoints.py
================================================================================

# tests/api/v1/test_auth_endpoints.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from datetime import datetime, timedelta, timezone
from typing import Any, Dict

from fastapi.testclient import TestClient
from jose import jwt
from sqlalchemy.orm import Session
from _pytest.capture import CaptureFixture

from app.core.config import settings
from app.schemas.user import UserCreate
from app.crud import user as crud_user
from app.core import security

# =======================================================================================================
# --- Testes para Endpoints de Autenticação ---                                                      #####
# =======================================================================================================

def test_read_root(client: TestClient) -> None:
    """Testa o endpoint raiz '/'."""
    response = client.get("/")
    assert response.status_code == 200
    assert "message" in response.json()
    assert settings.PROJECT_NAME in response.json()["message"]


def test_health_check(client: TestClient) -> None:
    """Testa o endpoint de health check '/health'."""
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "ok"}


def test_register_new_user(client: TestClient, db_session: Session) -> None:
    """
    Testa o endpoint de registro de novo usuário (/api/v1/auth/register).
    Verifica:
    - Registro bem-sucedido com dados válidos.
    - Resposta correta (status 201, dados do usuário).
    - Usuário é realmente criado no banco de dados.
    - Tentativa de registro com e-mail duplicado resulta em erro 400.
    """
    # Cenário 1: Registro bem-sucedido
    user_data = {
        "email": "testregister@example.com",
        "password": "aSecurePassword123",
        "full_name": "Test Register User"
    }
    response = client.post(f"{settings.API_V1_STR}/auth/register", json=user_data)

    assert response.status_code == 201, f"Status code should be 201. Response: {response.text}"
    created_user_data = response.json()
    assert created_user_data["email"] == user_data["email"]
    assert created_user_data["full_name"] == user_data["full_name"]
    assert "id" in created_user_data
    assert "hashed_password" not in created_user_data 

    # Verifica no banco se o usuário foi realmente criado
    db_user = crud_user.get_user_by_email(db_session, email=user_data["email"])
    assert db_user is not None
    assert db_user.email == user_data["email"]
    assert db_user.full_name == user_data["full_name"]
    assert db_user.is_active is True 

    # Cenário 2: Tentativa de registro com e-mail duplicado
    response_duplicate = client.post(f"{settings.API_V1_STR}/auth/register", json=user_data)
    assert response_duplicate.status_code == 400, \
        f"Status code for duplicate email should be 400. Response: {response_duplicate.text}"
    error_data = response_duplicate.json()
    assert "detail" in error_data
    assert "already exists" in error_data["detail"].lower()


def test_login_for_access_token(client: TestClient, db_session: Session) -> None:
    """
    Testa o endpoint de login (/api/v1/auth/login).
    Verifica:
    - Login bem-sucedido com credenciais válidas.
    - Resposta contém access_token e token_type.
    - Falha no login com e-mail incorreto.
    - Falha no login com senha incorreta.
    - Falha no login para usuário inativo.
    """
    base_user_email = "testlogin@example.com"
    base_user_password = "loginPassword123"

    # Cria um usuário para testar o login
    user_in_db = UserCreate(email=base_user_email, password=base_user_password, full_name="Test Login User")
    crud_user.create_user(db=db_session, user=user_in_db)

    # Cenário 1: Login bem-sucedido
    login_data = {"username": base_user_email, "password": base_user_password} 
    response = client.post(f"{settings.API_V1_STR}/auth/login", data=login_data) 

    assert response.status_code == 200, f"Status code should be 200. Response: {response.text}"
    token_data = response.json()
    assert "access_token" in token_data
    assert token_data["token_type"] == "bearer"

    # Cenário 2: E-mail incorreto
    login_data_wrong_email = {"username": "wrong@example.com", "password": base_user_password}
    response_wrong_email = client.post(f"{settings.API_V1_STR}/auth/login", data=login_data_wrong_email)
    assert response_wrong_email.status_code == 401, \
        f"Status code for wrong email should be 401. Response: {response_wrong_email.text}"

    # Cenário 3: Senha incorreta
    login_data_wrong_password = {"username": base_user_email, "password": "wrongPassword"}
    response_wrong_password = client.post(f"{settings.API_V1_STR}/auth/login", data=login_data_wrong_password)
    assert response_wrong_password.status_code == 401, \
        f"Status code for wrong password should be 401. Response: {response_wrong_password.text}"

    # Cenário 4: Usuário inativo
    user_from_db = crud_user.get_user_by_email(db=db_session, email=base_user_email)
    assert user_from_db is not None
    user_from_db.is_active = False
    db_session.add(user_from_db)
    db_session.commit()
    db_session.refresh(user_from_db)

    response_inactive = client.post(f"{settings.API_V1_STR}/auth/login", data=login_data)
    assert response_inactive.status_code == 400, \
        f"Status code for inactive user login should be 400. Response: {response_inactive.text}"


def get_valid_token_headers(client: TestClient, db: Session, email: str, password: str) -> Dict[str, str]:
    """Gera e retorna cabeçalhos de autorização com um token válido."""
    login_data = {"username": email, "password": password}
    response = client.post(f"{settings.API_V1_STR}/auth/login", data=login_data)
    response.raise_for_status()
    tokens = response.json()
    access_token = tokens["access_token"]
    return {"Authorization": f"Bearer {access_token}"}


def test_read_users_me(client: TestClient, db_session: Session) -> None:
    """
    Testa o endpoint /me para obter o usuário atual.
    Verifica:
    - Acesso bem-sucedido com token válido de usuário ativo.
    - Falha de acesso sem token (401).
    - Falha de acesso com token inválido (401).
    - Falha de acesso com token de usuário inativo (cobre get_current_active_user).
    """
    user_email = "testme@example.com"
    user_password = "mePassword123"
    user_full_name = "Test Me User"

    # Cria um usuário ativo
    user_in_create = UserCreate(email=user_email, password=user_password, full_name=user_full_name, is_active=True)
    created_user = crud_user.create_user(db=db_session, user=user_in_create)

    # Cenário 1: Acesso bem-sucedido com token válido
    headers = get_valid_token_headers(client, db_session, user_email, user_password)
    response = client.get(f"{settings.API_V1_STR}/auth/me", headers=headers)
    assert response.status_code == 200, f"Status code should be 200. Response: {response.text}"
    current_user_data = response.json()
    assert current_user_data["email"] == user_email
    assert current_user_data["full_name"] == user_full_name
    assert current_user_data["id"] == created_user.id

    # Cenário 2: Falha de acesso sem token
    response_no_token = client.get(f"{settings.API_V1_STR}/auth/me")
    assert response_no_token.status_code == 401, \
        f"Status code without token should be 401. Response: {response_no_token.text}"

    # Cenário 3: Falha de acesso com token inválido
    invalid_headers = {"Authorization": "Bearer aninvalidtoken"}
    response_invalid_token = client.get(f"{settings.API_V1_STR}/auth/me", headers=invalid_headers)
    assert response_invalid_token.status_code == 401, \
        f"Status code with invalid token should be 401. Response: {response_invalid_token.text}"

    # Cenário 4: Falha de acesso com token de usuário inativo
    created_user_model = crud_user.get_user_by_email(db_session, email=user_email)
    assert created_user_model is not None
    created_user_model.is_active = False
    db_session.add(created_user_model)
    db_session.commit()
    response_inactive_user = client.get(f"{settings.API_V1_STR}/auth/me", headers=headers)
    assert response_inactive_user.status_code == 400, \
        f"Status code with token of inactive user should be 400. Response: {response_inactive_user.text}"
    

def test_read_current_superuser_as_superuser(client: TestClient, db_session: Session) -> None:
    """
    Testa o acesso ao endpoint de superusuário por um superusuário ativo.
    """
    superuser_email = "superuser@example.com"
    superuser_password = "superPassword123"
    
    # Cria um superusuário ativo
    user_in_create = UserCreate(
        email=superuser_email,
        password=superuser_password,
        full_name="Super User Test",
        is_active=True,
        is_superuser=True
    )
    crud_user.create_user(db=db_session, user=user_in_create)

    headers = get_valid_token_headers(client, db_session, superuser_email, superuser_password)
    response = client.get(f"{settings.API_V1_STR}/auth/me/superuser", headers=headers)
    
    assert response.status_code == 200, \
        f"Superuser should access superuser endpoint. Response: {response.text}"
    returned_user = response.json()
    assert returned_user["email"] == superuser_email
    assert returned_user["is_superuser"] is True


def test_read_current_superuser_as_normal_user(client: TestClient, db_session: Session) -> None:
    """
    Testa a falha de acesso ao endpoint de superusuário por um usuário normal ativo.
    """
    normal_user_email = "normaluser_for_superuser_test@example.com"
    normal_user_password = "normalPassword123"

    # Cria um usuário normal ativo
    user_in_create = UserCreate(
        email=normal_user_email,
        password=normal_user_password,
        full_name="Normal User Test",
        is_active=True,
        is_superuser=False
    )
    crud_user.create_user(db=db_session, user=user_in_create)

    headers = get_valid_token_headers(client, db_session, normal_user_email, normal_user_password)
    response = client.get(f"{settings.API_V1_STR}/auth/me/superuser", headers=headers)
    
    assert response.status_code == 403, \
        f"Normal user should get 403 on superuser endpoint. Response: {response.text}"
    error_data = response.json()
    assert "detail" in error_data
    assert "doesn't have enough privileges" in error_data["detail"]


def test_read_current_superuser_as_inactive_superuser(client: TestClient, db_session: Session) -> None:
    """
    Testa a falha de acesso ao endpoint de superusuário por um superusuário inativo.
    A dependência get_current_active_user (que get_current_active_superuser usa)
    deve barrar o acesso antes mesmo da verificação de superusuário.
    """
    inactive_superuser_email = "inactivesuper@example.com"
    inactive_superuser_password = "inactiveSuperPass"

    user_in_create = UserCreate(
        email=inactive_superuser_email,
        password=inactive_superuser_password,
        full_name="Inactive Super User",
        is_active=False,
        is_superuser=True
    )
    crud_user.create_user(db=db_session, user=user_in_create)
    
    temp_active_email = "temp_active_for_inactive_test@example.com"
    crud_user.create_user(db=db_session, user=UserCreate(email=temp_active_email, password=inactive_superuser_password, is_active=True, is_superuser=True))
    
    user_to_make_inactive = crud_user.get_user_by_email(db_session, temp_active_email)
    assert user_to_make_inactive is not None
    
    headers = get_valid_token_headers(client, db_session, temp_active_email, inactive_superuser_password) # Obtém token enquanto ativo

    user_to_make_inactive.is_active = False 
    db_session.add(user_to_make_inactive)
    db_session.commit()

    response = client.get(f"{settings.API_V1_STR}/auth/me/superuser", headers=headers)
    
    assert response.status_code == 400, \
        f"Inactive superuser should get 400. Response: {response.text}"
    error_data = response.json()
    assert "detail" in error_data
    assert "Inactive user" in error_data["detail"]


def test_token_data_validation_error_in_get_current_user(client: TestClient):
    """
    Força um ValidationError ao criar TokenData dentro de get_current_user.
    O 'sub' do token é uma string, mas não é um email válido para Pydantic EmailStr.
    """
    payload_invalid_email_format: Dict[str, Any] = {
        "sub": "plainstringnotaschemaemail",
        "exp": datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    }
    token = jwt.encode(payload_invalid_email_format, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    headers = {"Authorization": f"Bearer {token}"}
    response = client.get(f"{settings.API_V1_STR}/auth/me", headers=headers)
    assert response.status_code == 401
    assert "Could not validate credentials" in response.json()["detail"]


def test_get_current_user_with_invalid_sub_format(client: TestClient, db_session: Session) -> None:
    """Testa get_current_user com um 'sub' no token que não é um e-mail válido."""
    invalid_sub_payload: Dict[str, Any] = {
        "sub": "not-an-email",
        "exp": datetime.now(timezone.utc) + timedelta(minutes=15)
    }
    invalid_sub_token = jwt.encode(invalid_sub_payload, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    headers = {"Authorization": f"Bearer {invalid_sub_token}"}

    response = client.get(f"{settings.API_V1_STR}/auth/me", headers=headers)
    assert response.status_code == 401


def test_get_current_user_with_token_missing_sub_claim(client: TestClient) -> None:
    """
    Testa get_current_user com um token JWT que é válido mas não contém a claim 'sub'.
    Isso deve acionar a credentials_exception quando token_email_from_payload é None.
    """
    exp_time_minutes = settings.ACCESS_TOKEN_EXPIRE_MINUTES
    payload_missing_sub: Dict[str, Any] = {
        "user_id": 123, # Alguma outra claim
        "exp": datetime.now(timezone.utc) + timedelta(minutes=exp_time_minutes)
    }
    token_missing_sub = jwt.encode(payload_missing_sub, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    headers = {"Authorization": f"Bearer {token_missing_sub}"}

    response = client.get(f"{settings.API_V1_STR}/auth/me", headers=headers)
    assert response.status_code == 401
    assert "Could not validate credentials" in response.json()["detail"]


def test_get_current_user_with_valid_token_for_nonexistent_user(client: TestClient, db_session: Session) -> None:
    """
    Testa get_current_user com um token JWT válido, mas para um email
    que não existe mais no banco de dados.
    Isso deve cobrir o 'if user is None: raise credentials_exception'.
    """
    non_existent_email = "iamnotinthedb@example.com"
    exp_time_minutes = settings.ACCESS_TOKEN_EXPIRE_MINUTES
    
    payload: Dict[str, Any] = {
        "sub": non_existent_email,
        "exp": datetime.now(timezone.utc) + timedelta(minutes=exp_time_minutes)
    }
    token = jwt.encode(payload, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    headers = {"Authorization": f"Bearer {token}"}

    response = client.get(f"{settings.API_V1_STR}/auth/me", headers=headers)
    
    assert response.status_code == 401 
    assert "Could not validate credentials" in response.json()["detail"]

def test_update_user_me_full_name(client: TestClient, db_session: Session) -> None:
    """Testa a atualização do full_name do usuário autenticado."""
    user_email = "updateprofile@example.com"
    user_password = "profilePassword123"
    user_full_name_initial = "Initial Profile Name"
    crud_user.create_user(db_session, UserCreate(email=user_email, password=user_password, full_name=user_full_name_initial))
    
    headers = get_valid_token_headers(client, db_session, user_email, user_password)
    
    new_full_name = "Updated Profile Name"
    update_payload = {"full_name": new_full_name}
    
    response = client.patch(f"{settings.API_V1_STR}/auth/me", headers=headers, json=update_payload)
    
    assert response.status_code == 200, response.text
    updated_user_data = response.json()
    assert updated_user_data["email"] == user_email 
    assert updated_user_data["full_name"] == new_full_name
    assert updated_user_data["is_active"] is True 


def test_update_user_me_email(client: TestClient, db_session: Session) -> None:
    """Testa a atualização do email do usuário autenticado."""
    user_email_initial = "updateemail_initial@example.com"
    user_password = "emailPassword123"
    crud_user.create_user(db_session, UserCreate(email=user_email_initial, password=user_password, full_name="Email User"))
    
    headers = get_valid_token_headers(client, db_session, user_email_initial, user_password)
    
    user_email_new = "updateemail_new@example.com"
    update_payload = {"email": user_email_new}
    
    response = client.patch(f"{settings.API_V1_STR}/auth/me", headers=headers, json=update_payload)
    
    assert response.status_code == 200, response.text
    updated_user_data = response.json()
    assert updated_user_data["email"] == user_email_new
    
    new_login_headers = get_valid_token_headers(client, db_session, user_email_new, user_password)
    response_me_new_email = client.get(f"{settings.API_V1_STR}/auth/me", headers=new_login_headers)
    assert response_me_new_email.status_code == 200


def test_update_user_me_email_conflict(client: TestClient, db_session: Session) -> None:
    """Testa a tentativa de atualizar o email para um já existente por outro usuário."""
    user1_email = "user1_conflict@example.com"
    user1_password = "password1"
    crud_user.create_user(db_session, UserCreate(email=user1_email, password=user1_password, full_name="User One"))

    user2_email = "user2_tryingtoconflict@example.com"
    user2_password = "password2"
    crud_user.create_user(db_session, UserCreate(email=user2_email, password=user2_password, full_name="User Two"))

    headers_user2 = get_valid_token_headers(client, db_session, user2_email, user2_password)
    
    update_payload = {"email": user1_email}
    response = client.patch(f"{settings.API_V1_STR}/auth/me", headers=headers_user2, json=update_payload)
    
    assert response.status_code == 400, response.text
    assert "Email already registered" in response.json()["detail"]


def test_update_user_me_cannot_change_status(client: TestClient, db_session: Session) -> None:
    """Testa que o usuário não pode mudar is_active ou is_superuser via PATCH /me."""
    user_email = "statuschange@example.com"
    user_password = "statusPassword123"
    crud_user.create_user(db_session, UserCreate(email=user_email, password=user_password, is_active=True, is_superuser=False))
    
    headers = get_valid_token_headers(client, db_session, user_email, user_password)
    
    update_payload: Dict[str, Any] = { 
        "is_active": False,         
        "is_superuser": True,       
        "full_name": "New Name"     
    }
    response = client.patch(f"{settings.API_V1_STR}/auth/me", headers=headers, json=update_payload)
    
    assert response.status_code == 200, response.text
    updated_data = response.json()
    assert updated_data["full_name"] == "New Name"
    assert updated_data["is_active"] is True    
    assert updated_data["is_superuser"] is False


def test_update_current_user_password_success(client: TestClient, db_session: Session) -> None:
    """Testa a mudança de senha bem-sucedida do usuário autenticado."""
    user_email = "changepass@example.com"
    old_password = "oldPassword123"
    new_password = "newSecurePassword456"

    crud_user.create_user(db_session, UserCreate(email=user_email, password=old_password))
    headers = get_valid_token_headers(client, db_session, user_email, old_password)

    password_change_data = {
        "current_password": old_password,
        "new_password": new_password,
        "new_password_confirm": new_password
    }
    response = client.put(
        f"{settings.API_V1_STR}/auth/me/password", headers=headers, json=password_change_data
    )
    assert response.status_code == 204, response.text

    login_with_new_pass_data = {"username": user_email, "password": new_password}
    response_login_new = client.post(
        f"{settings.API_V1_STR}/auth/login", data=login_with_new_pass_data
    )
    assert response_login_new.status_code == 200, response_login_new.text

    login_with_old_pass_data = {"username": user_email, "password": old_password}
    response_login_old = client.post(
        f"{settings.API_V1_STR}/auth/login", data=login_with_old_pass_data
    )
    assert response_login_old.status_code == 401, response_login_old.text


def test_update_current_user_password_wrong_current_password(client: TestClient, db_session: Session) -> None:
    """Testa a falha na mudança de senha quando a senha atual fornecida está incorreta."""
    user_email = "wrongcurrpass@example.com"
    correct_current_password = "correctPassword"
    new_password = "newPassword"
    crud_user.create_user(db_session, UserCreate(email=user_email, password=correct_current_password))
    headers = get_valid_token_headers(client, db_session, user_email, correct_current_password)

    password_change_data = {
        "current_password": "thisIsTheWrongCurrentPassword",
        "new_password": new_password,
        "new_password_confirm": new_password
    }
    response = client.put(
        f"{settings.API_V1_STR}/auth/me/password", headers=headers, json=password_change_data
    )
    assert response.status_code == 400, response.text
    assert "Incorrect current password" in response.json()["detail"]


def test_update_current_user_password_new_passwords_mismatch(client: TestClient, db_session: Session) -> None:
    """Testa a falha na mudança de senha quando a nova senha e a confirmação não correspondem."""
    user_email = "passmismatch@example.com"
    current_password = "currentPassword"
    crud_user.create_user(db_session, UserCreate(email=user_email, password=current_password))
    headers = get_valid_token_headers(client, db_session, user_email, current_password)

    password_change_data = {
        "current_password": current_password,
        "new_password": "newPassword1",
        "new_password_confirm": "newPassword2" 
    }
    response = client.put(
        f"{settings.API_V1_STR}/auth/me/password", headers=headers, json=password_change_data
    )
    assert response.status_code == 422, response.text 
    error_detail = response.json()["detail"][0]
    assert error_detail["type"] == "value_error"
    assert "As senhas não correspondem" in error_detail["msg"]


def test_update_current_user_password_new_same_as_old(client: TestClient, db_session: Session) -> None:
    """Testa a falha na mudança de senha quando a nova senha é igual à senha antiga."""
    user_email = "pass_same_as_old@example.com"
    current_password = "samePassword123"
    crud_user.create_user(db_session, UserCreate(email=user_email, password=current_password))
    headers = get_valid_token_headers(client, db_session, user_email, current_password)

    password_change_data = {
        "current_password": current_password,
        "new_password": current_password, 
        "new_password_confirm": current_password
    }
    response = client.put(
        f"{settings.API_V1_STR}/auth/me/password", headers=headers, json=password_change_data
    )
    assert response.status_code == 400, response.text
    assert "New password cannot be the same" in response.json()["detail"]


def test_delete_user_me_success(client: TestClient, db_session: Session) -> None:
    """Testa a deleção bem-sucedida da conta do usuário autenticado."""
    user_email = "delete_my_account@example.com"
    user_password = "deleteMePassword123"

    user_to_delete = crud_user.create_user(
        db_session, UserCreate(email=user_email, password=user_password)
    )
    user_id_before_delete = user_to_delete.id

    headers = get_valid_token_headers(client, db_session, user_email, user_password)

    response_delete = client.delete(f"{settings.API_V1_STR}/auth/me", headers=headers)
    assert response_delete.status_code == 204, \
        f"Status code should be 204 No Content. Response: {response_delete.content}" 

    user_in_db_after_delete = crud_user.get_user(db_session, user_id=user_id_before_delete)
    assert user_in_db_after_delete is None, "User should no longer exist in DB after deletion."

    response_me_after_delete = client.get(f"{settings.API_V1_STR}/auth/me", headers=headers)
    assert response_me_after_delete.status_code == 401, \
        "Accessing /me with token of deleted user should result in 401 (user not found)."
    
    login_data_deleted_user = {"username": user_email, "password": user_password}
    response_login_deleted = client.post(
        f"{settings.API_V1_STR}/auth/login", data=login_data_deleted_user
    )
    assert response_login_deleted.status_code == 401, \
        "Login attempt for a deleted user should result in 401."


def test_delete_user_me_no_token(client: TestClient) -> None:
    """Testa a falha ao tentar deletar sem um token de autenticação."""
    response = client.delete(f"{settings.API_V1_STR}/auth/me")
    assert response.status_code == 401, \
        "Attempting to delete /me without a token should result in 401."


def test_delete_user_me_invalid_token(client: TestClient) -> None:
    """Testa a falha ao tentar deletar com um token inválido."""
    headers = {"Authorization": "Bearer aninvalidtoken"}
    response = client.delete(f"{settings.API_V1_STR}/auth/me", headers=headers)
    assert response.status_code == 401, \
        "Attempting to delete /me with an invalid token should result in 401."
    

def test_request_password_recovery_user_exists(
    client: TestClient,
    db_session: Session,
    capsys: CaptureFixture[str] 
) -> None:
    """Testa a solicitação de recuperação de senha para um usuário existente."""
    user_email = "recovermyP4ssw0rd@example.com"
    user_password = "oldPassword123"
    crud_user.create_user(db_session, UserCreate(email=user_email, password=user_password))

    recovery_payload = {"email": user_email}
    response = client.post(f"{settings.API_V1_STR}/auth/password-recovery", json=recovery_payload)

    assert response.status_code == 200, response.text
    assert response.json() == {"message": "Se um usuário com este email existir, um link de recuperação foi enviado."}
    
    captured = capsys.readouterr()
    assert "SIMULAÇÃO DE ENVIO DE E-MAIL" in captured.out
    assert f"Para: {user_email}" in captured.out
    assert "Use o seguinte token para resetar sua senha" in captured.out


def test_request_password_recovery_user_does_not_exist(
    client: TestClient,
    db_session: Session,
    capsys: CaptureFixture[str] 
) -> None:
    """
    Testa a solicitação de recuperação de senha para um e-mail não existente.
    Deve retornar a mesma mensagem genérica para não revelar a existência do usuário.
    """
    non_existent_email = "idonotexist@example.com"
    recovery_payload = {"email": non_existent_email}
    response = client.post(f"{settings.API_V1_STR}/auth/password-recovery", json=recovery_payload)

    assert response.status_code == 200, response.text
    assert response.json() == {"message": "Se um usuário com este email existir, um link de recuperação foi enviado."}
    
    captured = capsys.readouterr()
    assert "SIMULAÇÃO DE ENVIO DE E-MAIL" not in captured.out 


def test_reset_user_password_success(
    client: TestClient,
    db_session: Session,
    capsys: CaptureFixture[str] 
) -> None:
    """Testa o reset de senha bem-sucedido com um token válido."""
    user_email = "resetthispassword@example.com"
    old_password = "oldPassword"
    new_password = "aBrandNewPassword123"

    _ = crud_user.create_user(db_session, UserCreate(email=user_email, password=old_password))
    
    reset_token = security.create_password_reset_token(email=user_email)

    reset_form_data = {
        "token": reset_token,
        "new_password": new_password,
        "new_password_confirm": new_password
    }
    response = client.post(f"{settings.API_V1_STR}/auth/reset-password/", json=reset_form_data)
    assert response.status_code == 204, response.content 

    login_data = {"username": user_email, "password": new_password}
    response_login = client.post(f"{settings.API_V1_STR}/auth/login", data=login_data)
    assert response_login.status_code == 200, response_login.text
    assert "access_token" in response_login.json()

    login_data_old_pass = {"username": user_email, "password": old_password}
    response_login_old = client.post(f"{settings.API_V1_STR}/auth/login", data=login_data_old_pass)
    assert response_login_old.status_code == 401, response_login_old.text

    captured = capsys.readouterr()
    assert "Sua senha foi alterada com sucesso." in captured.out
    assert f"Para: {user_email}" in captured.out


def test_reset_user_password_invalid_token(client: TestClient, db_session: Session) -> None:
    """Testa a falha no reset de senha com um token inválido ou expirado."""
    new_password = "newPasswordAttempt"
    reset_form_data_invalid_token = {
        "token": "this.is.an.invalid.token",
        "new_password": new_password,
        "new_password_confirm": new_password
    }
    response = client.post(f"{settings.API_V1_STR}/auth/reset-password/", json=reset_form_data_invalid_token)
    assert response.status_code == 400, response.text
    assert "Token de recuperação de senha inválido ou expirado" in response.json()["detail"]

    user_email_for_expired_token = "expiredtokenuser@example.com"
    _ = crud_user.create_user(db_session, UserCreate(email=user_email_for_expired_token, password="password"))
    
    expired_like_token_payload: Dict[str, Any] = {
        "sub": user_email_for_expired_token,
        "type": "not_password_reset",
        "exp": datetime.now(timezone.utc) - timedelta(hours=settings.PASSWORD_RESET_TOKEN_EXPIRE_HOURS + 1)
    }
    expired_token = jwt.encode(expired_like_token_payload, settings.SECRET_KEY, algorithm=settings.ALGORITHM)

    reset_form_data_expired_token = {
        "token": expired_token,
        "new_password": new_password,
        "new_password_confirm": new_password
    }
    response_expired = client.post(f"{settings.API_V1_STR}/auth/reset-password/", json=reset_form_data_expired_token)
    assert response_expired.status_code == 400, response_expired.text
    assert "Token de recuperação de senha inválido ou expirado" in response_expired.json()["detail"]


def test_reset_user_password_user_not_found_with_valid_token_logic(client: TestClient, db_session: Session) -> None:
    """
    Testa o cenário onde um token de reset é válido, mas o usuário
    (identificado pelo email no token) não existe mais no banco.
    Isso é um caso de borda, pois o token só deveria ser gerado para usuários existentes.
    """
    email_in_valid_token = "user_that_will_be_deleted@example.com"
    new_password = "newPasswordIfUserExisted"

    reset_token = security.create_password_reset_token(email=email_in_valid_token)

    reset_form_data = {
        "token": reset_token,
        "new_password": new_password,
        "new_password_confirm": new_password
    }
    response = client.post(f"{settings.API_V1_STR}/auth/reset-password/", json=reset_form_data)
    assert response.status_code == 404, response.text 
    assert "Usuário não encontrado" in response.json()["detail"]


def test_reset_user_password_inactive_user(client: TestClient, db_session: Session) -> None:
    """Testa o reset de senha para um usuário que está inativo."""
    user_email = "inactive_reset@example.com"
    old_password = "oldPassword"
    new_password = "newPasswordForInactive"

    user_db = crud_user.create_user(db_session, UserCreate(email=user_email, password=old_password))
    user_db.is_active = False
    db_session.add(user_db)
    db_session.commit()
    db_session.refresh(user_db)
    
    reset_token = security.create_password_reset_token(email=user_email)
    reset_form_data = {
        "token": reset_token,
        "new_password": new_password,
        "new_password_confirm": new_password
    }
    response = client.post(f"{settings.API_V1_STR}/auth/reset-password/", json=reset_form_data)
    assert response.status_code == 400, response.text
    assert "Usuário inativo" in response.json()["detail"]


def test_reset_user_password_passwords_mismatch(client: TestClient, db_session: Session) -> None:
    """Testa a falha no reset de senha quando a nova senha e a confirmação não correspondem."""
    user_email = "reset_mismatch@example.com"
    crud_user.create_user(db_session, UserCreate(email=user_email, password="password"))
    reset_token = security.create_password_reset_token(email=user_email)

    reset_form_data = {
        "token": reset_token,
        "new_password": "newPassword1",
        "new_password_confirm": "newPassword2Different" 
    }
    response = client.post(f"{settings.API_V1_STR}/auth/reset-password/", json=reset_form_data)
    assert response.status_code == 422, response.text 
    error_detail = response.json()["detail"][0]
    assert error_detail["type"] == "value_error"
    assert "As senhas não correspondem" in error_detail["msg"]

================================================================================
Capítulo 29: backend\tests\api\v1\test_users_admin_endpoints.py
================================================================================

# backend/tests/api/v1/test_users_admin_endpoints.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from typing import Dict
from fastapi.testclient import TestClient
from sqlalchemy.orm import Session

from app.core.config import settings
from app.schemas.user import UserCreate, UserUpdate
from app.crud import user as crud_user
from tests.utils.user import create_random_user, random_email, random_lower_string
from app.db.models.user import User as UserModel
from app.core import security 


# =======================================================================================================
# --- Testes para Endpoints de Administração de Usuários ---                                        #####
# =======================================================================================================

# =======================================================================================================
# --- Testes para GET /api/v1/users/ ---                                                            #####
# =======================================================================================================

def test_read_users_as_superuser(
    client: TestClient, superuser_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa a leitura de múltiplos usuários por um superusuário.
    Cria alguns usuários para garantir que há dados a serem retornados.
    """
    create_random_user(db_session)
    create_random_user(db_session)
    create_random_user(db_session)

    response = client.get(f"{settings.API_V1_STR}/users/", headers=superuser_token_headers)
    assert response.status_code == 200
    all_users = response.json()
    assert len(all_users) >= 3
    for user_data in all_users:
        assert "email" in user_data
        assert "id" in user_data
        assert "hashed_password" not in user_data


def test_read_users_pagination_as_superuser(
    client: TestClient, superuser_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa a paginação na leitura de usuários por um superusuário.
    """
    for _ in range(15):
        create_random_user(db_session)

    response_limit = client.get(f"{settings.API_V1_STR}/users/?limit=5", headers=superuser_token_headers)
    assert response_limit.status_code == 200
    limited_users = response_limit.json()
    assert len(limited_users) == 5

    response_skip_limit = client.get(f"{settings.API_V1_STR}/users/?skip=5&limit=5", headers=superuser_token_headers)
    assert response_skip_limit.status_code == 200
    skipped_users = response_skip_limit.json()
    assert len(skipped_users) == 5
    if limited_users and skipped_users:
        assert limited_users[0]["id"] != skipped_users[0]["id"]

    response_skip_too_much = client.get(f"{settings.API_V1_STR}/users/?skip=100", headers=superuser_token_headers)
    assert response_skip_too_much.status_code == 200
    assert len(response_skip_too_much.json()) == 0


def test_read_users_as_normal_user_forbidden(
    client: TestClient, normal_user_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa que um usuário normal não pode listar todos os usuários.
    """
    response = client.get(f"{settings.API_V1_STR}/users/", headers=normal_user_token_headers)
    assert response.status_code == 403
    assert "doesn't have enough privileges" in response.json()["detail"].lower()


def test_read_users_unauthenticated(client: TestClient, db_session: Session) -> None:
    """
    Testa que um usuário não autenticado não pode listar todos os usuários.
    """
    response = client.get(f"{settings.API_V1_STR}/users/")
    assert response.status_code == 401

# =======================================================================================================
# --- Testes para GET /api/v1/users/{user_id} ---                                                   #####
# =======================================================================================================

def test_read_user_by_id_as_superuser(
    client: TestClient, superuser_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa a leitura de um usuário específico por ID por um superusuário.
    """
    user_to_find: UserModel = create_random_user(db_session)
    assert user_to_find.id is not None
    response = client.get(f"{settings.API_V1_STR}/users/{user_to_find.id}", headers=superuser_token_headers)
    assert response.status_code == 200
    found_user_data = response.json()
    assert found_user_data["email"] == user_to_find.email
    assert found_user_data["id"] == user_to_find.id
    assert found_user_data["full_name"] == user_to_find.full_name
    assert "hashed_password" not in found_user_data


def test_read_user_by_id_not_found_as_superuser(
    client: TestClient, superuser_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa a leitura de um ID de usuário não existente por um superusuário.
    """
    non_existent_id = 99999
    response = client.get(f"{settings.API_V1_STR}/users/{non_existent_id}", headers=superuser_token_headers)
    assert response.status_code == 404
    assert "não foi encontrado" in response.json()["detail"]


def test_read_user_by_id_as_normal_user_forbidden(
    client: TestClient, normal_user_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa que um usuário normal não pode obter outro usuário por ID.
    """
    another_user: UserModel = create_random_user(db_session)
    assert another_user.id is not None
    response = client.get(f"{settings.API_V1_STR}/users/{another_user.id}", headers=normal_user_token_headers)
    assert response.status_code == 403
    assert "doesn't have enough privileges" in response.json()["detail"].lower()


def test_read_user_by_id_unauthenticated(client: TestClient, db_session: Session) -> None:
    """
    Testa que um usuário não autenticado não pode obter usuário por ID.
    """
    user_to_find: UserModel = create_random_user(db_session)
    assert user_to_find.id is not None
    response = client.get(f"{settings.API_V1_STR}/users/{user_to_find.id}")
    assert response.status_code == 401


# =======================================================================================================
# --- Testes para POST /api/v1/users/ ---                                                           #####
# =======================================================================================================

def test_create_user_by_admin_as_superuser(
    client: TestClient, superuser_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa a criação de um novo usuário por um superusuário, definindo is_superuser.
    """
    email = random_email()
    password = random_lower_string(10)
    full_name = "AdminCreated Superuser"
    user_data_in = UserCreate(
        email=email,
        password=password,
        full_name=full_name,
        is_active=True,
        is_superuser=True, # Testando a criação de outro superuser
    )
    response = client.post(f"{settings.API_V1_STR}/users/", headers=superuser_token_headers, json=user_data_in.model_dump())
    assert response.status_code == 201
    created_user_data = response.json()
    assert created_user_data["email"] == email
    assert created_user_data["full_name"] == full_name
    assert created_user_data["is_active"] is True
    assert created_user_data["is_superuser"] is True # Verifica se o flag foi setado

    db_user: UserModel | None = crud_user.get_user_by_email(db_session, email=email)
    assert db_user is not None
    assert db_user.is_superuser is True


def test_create_user_by_admin_existing_email_as_superuser(
    client: TestClient, superuser_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa a tentativa de criar um usuário com email já existente por um superusuário.
    """
    existing_user: UserModel = create_random_user(db_session)
    password = random_lower_string(10)
    user_data_in = UserCreate(
        email=existing_user.email,
        password=password,
        full_name="Duplicate Email User",
    )
    response = client.post(f"{settings.API_V1_STR}/users/", headers=superuser_token_headers, json=user_data_in.model_dump())
    assert response.status_code == 400
    assert "já existe" in response.json()["detail"]


def test_create_user_by_admin_as_normal_user_forbidden(
    client: TestClient, normal_user_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa que um usuário normal não pode criar usuários via endpoint de admin.
    """
    email = random_email()
    password = random_lower_string(10)
    user_data_in = UserCreate(email=email, password=password)
    response = client.post(f"{settings.API_V1_STR}/users/", headers=normal_user_token_headers, json=user_data_in.model_dump())
    assert response.status_code == 403


# =======================================================================================================
# --- Testes para PUT /api/v1/users/{user_id} ---                                                   #####
# =======================================================================================================

def test_update_user_by_admin_as_superuser(
    client: TestClient, superuser_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa a atualização de um usuário por um superusuário, incluindo status e senha.
    """
    user_to_update: UserModel = create_random_user(db_session, is_active=True, is_superuser=False)
    assert user_to_update.id is not None

    new_full_name = "Updated Name by Admin"
    new_email = random_email()
    update_payload_schema = UserUpdate(
        full_name=new_full_name,
        email=new_email,
        is_active=False,
        is_superuser=True,
    )
    response_no_pass = client.put(
        f"{settings.API_V1_STR}/users/{user_to_update.id}", headers=superuser_token_headers, json=update_payload_schema.model_dump(exclude_unset=True)
    )
    assert response_no_pass.status_code == 200
    updated_user_data = response_no_pass.json()
    assert updated_user_data["email"] == new_email
    assert updated_user_data["full_name"] == new_full_name
    assert updated_user_data["is_active"] is False
    assert updated_user_data["is_superuser"] is True

    new_password = random_lower_string(12)
    update_payload_with_pass_schema = UserUpdate(
        password=new_password
    )
    response_with_pass = client.put(
        f"{settings.API_V1_STR}/users/{user_to_update.id}", headers=superuser_token_headers, json=update_payload_with_pass_schema.model_dump(exclude_unset=True)
    )
    assert response_with_pass.status_code == 200
    db_user_pass_updated: UserModel | None = crud_user.get_user(db_session, user_id=user_to_update.id)
    assert db_user_pass_updated is not None
    assert security.verify_password(new_password, db_user_pass_updated.hashed_password)
    assert db_user_pass_updated.email == new_email # Verifica se o email não foi revertido


def test_update_user_by_admin_email_conflict_as_superuser(
    client: TestClient, superuser_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa a falha ao atualizar email de um usuário para um email que já existe por outro usuário.
    """
    user1: UserModel = create_random_user(db_session)
    user2: UserModel = create_random_user(db_session)
    assert user1.id is not None and user2.id is not None
    update_data = UserUpdate(email=user1.email)

    response = client.put(
        f"{settings.API_V1_STR}/users/{user2.id}", headers=superuser_token_headers, json=update_data.model_dump(exclude_unset=True)
    )
    assert response.status_code == 400
    assert "novo email fornecido já está registrado" in response.json()["detail"]


def test_update_user_by_admin_not_found_as_superuser(
    client: TestClient, superuser_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa a atualização de um ID de usuário não existente por um superusuário.
    """
    non_existent_id = 999999
    update_data = UserUpdate(full_name="Any Name")
    response = client.put(
        f"{settings.API_V1_STR}/users/{non_existent_id}", headers=superuser_token_headers, json=update_data.model_dump(exclude_unset=True)
    )
    assert response.status_code == 404


def test_update_user_by_admin_as_normal_user_forbidden(
    client: TestClient, normal_user_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa que um usuário normal não pode atualizar outros usuários.
    """
    user_to_update: UserModel = create_random_user(db_session)
    assert user_to_update.id is not None
    update_data = UserUpdate(full_name="New Name by Normal User")
    response = client.put(
        f"{settings.API_V1_STR}/users/{user_to_update.id}", headers=normal_user_token_headers, json=update_data.model_dump(exclude_unset=True)
    )
    assert response.status_code == 403


# =======================================================================================================
# --- Testes para DELETE /api/v1/users/{user_id} ---                                                #####
# =======================================================================================================

def test_delete_user_by_admin_as_superuser(
    client: TestClient, superuser_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa a deleção de um usuário por um superusuário.
    """
    user_to_delete: UserModel = create_random_user(db_session)
    user_id_to_delete = user_to_delete.id
    assert user_id_to_delete is not None

    response = client.delete(
        f"{settings.API_V1_STR}/users/{user_id_to_delete}", headers=superuser_token_headers
    )
    assert response.status_code == 200
    deleted_user_data = response.json()
    assert deleted_user_data["id"] == user_id_to_delete
    assert deleted_user_data["email"] == user_to_delete.email

    user_in_db: UserModel | None = crud_user.get_user(db_session, user_id=user_id_to_delete)
    assert user_in_db is None


def test_delete_own_superuser_account_by_admin_endpoint_forbidden(
    client: TestClient, db_session: Session, superuser_token_headers: Dict[str, str] # Usa a fixture global
) -> None:
    """
    Testa que um superusuário não pode deletar a si mesmo via /users/{id} usando seu próprio token.
    """
    # Obtém o ID do superusuário da fixture (o usuário logado com superuser_token_headers)
    response_me = client.get(f"{settings.API_V1_STR}/auth/me", headers=superuser_token_headers)
    current_superuser_id = response_me.json()["id"]

    response = client.delete(
        f"{settings.API_V1_STR}/users/{current_superuser_id}", headers=superuser_token_headers
    )
    assert response.status_code == 403
    assert "não podem deletar a si mesmos" in response.json()["detail"]


def test_delete_user_by_admin_not_found_as_superuser(
    client: TestClient, superuser_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa a deleção de um ID de usuário não existente por um superusuário.
    """
    non_existent_id = 998877
    response = client.delete(
        f"{settings.API_V1_STR}/users/{non_existent_id}", headers=superuser_token_headers
    )
    assert response.status_code == 404


def test_delete_user_by_admin_as_normal_user_forbidden(
    client: TestClient, normal_user_token_headers: Dict[str, str], db_session: Session
) -> None:
    """
    Testa que um usuário normal não pode deletar outros usuários.
    """
    user_to_delete: UserModel = create_random_user(db_session)
    assert user_to_delete.id is not None
    response = client.delete(
        f"{settings.API_V1_STR}/users/{user_to_delete.id}", headers=normal_user_token_headers
    )
    assert response.status_code == 403

================================================================================
Capítulo 30: backend\tests\conftest.py
================================================================================

# backend/tests/conftest.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

import pytest
from typing import Generator, Dict
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.pool import StaticPool

from app.main import app
from app.api.deps import get_db
from app.db.base_class import Base
from app.core.config import settings
from app.schemas.user import UserCreate, EmailStr 
from app.crud import user as crud_user

from tests.utils.user import authentication_token_from_email, random_email, random_lower_string

# =======================================================================================================
# --- Configurações de URL e Fixtures ---                                                           #####
# =======================================================================================================


actual_test_db_url: str = settings.DATABASE_URL_TEST if settings.DATABASE_URL_TEST is not None else "sqlite:///:memory:"

if actual_test_db_url.startswith("sqlite"):
    engine_test = create_engine(
        actual_test_db_url,
        connect_args={"check_same_thread": False},
        poolclass=StaticPool,
    )
else:
    engine_test = create_engine(actual_test_db_url)

TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine_test)

@pytest.fixture(scope="session", autouse=True)
def setup_test_db():
    Base.metadata.create_all(bind=engine_test)
    yield
    if not actual_test_db_url.startswith("sqlite:///:memory:"):
        Base.metadata.drop_all(bind=engine_test)

@pytest.fixture(scope="function")
def db_session() -> Generator[Session, None, None]:
    connection = engine_test.connect()
    transaction = connection.begin()
    session = TestingSessionLocal(bind=connection)
    yield session
    session.close()
    transaction.rollback()
    connection.close()

@pytest.fixture(scope="function")
def client(db_session: Session) -> Generator[TestClient, None, None]:
    """
    Fixture de escopo de função que fornece um FastAPI TestClient.
    Este client é configurado para usar o banco de dados de teste,
    sobrescrevendo a dependência 'get_db' da aplicação PARA CADA TESTE,
    usando a instância específica de db_session fornecida pela fixture.
    """
    def override_get_db() -> Generator[Session, None, None]:
        yield db_session

    app.dependency_overrides[get_db] = override_get_db
    with TestClient(app) as c:
        yield c
    del app.dependency_overrides[get_db]


@pytest.fixture(scope="function")
def superuser_token_headers(client: TestClient, db_session: Session) -> Dict[str, str]:
   
    email: EmailStr = settings.FIRST_SUPERUSER_EMAIL
    password: str = settings.FIRST_SUPERUSER_PASSWORD
    
    user = crud_user.get_user_by_email(db_session, email=email)
    if not user:
        user_in_create = UserCreate(
            email=email,
            password=password,
            is_superuser=True,
            is_active=True,
            full_name="Test Superuser"
        )
        crud_user.create_user_by_admin(db_session, user=user_in_create)
    
    return authentication_token_from_email(client=client, email=email, password=password)


@pytest.fixture(scope="function")
def normal_user_token_headers(client: TestClient, db_session: Session) -> Dict[str, str]:
    email = random_email()
    password = random_lower_string(8)
    user_in = UserCreate(email=email, password=password, is_active=True, is_superuser=False, full_name="Test Normal User")
    crud_user.create_user(db_session, user=user_in)
    return authentication_token_from_email(client=client, email=email, password=password)

================================================================================
Capítulo 31: backend\tests\core\test_security.py
================================================================================

# tests/core/test_security.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from app.core.security import (
    create_access_token,
    create_refresh_token,
    decode_token,
    get_password_hash,
    get_subject_from_token,
    verify_password,
)
from jose import jwt
from app.core.config import settings
from datetime import datetime, timedelta, timezone
from typing import Dict, Any 

# =======================================================================================================
# --- Testes ---                                                                                    #####
# =======================================================================================================

def test_password_hashing_and_verification():
    """
    Testa a geração de hash de senha e a verificação da senha.
    Verifica se:
    - O hash é diferente da senha original.
    - A senha correta é verificada com sucesso.
    - Uma senha incorreta falha na verificação.
    """
    password = "a_plain_password"
    hashed_password = get_password_hash(password)
    assert hashed_password != password, "Hashed password should not be the same as plain password"
    assert verify_password(password, hashed_password), "Verification of correct password should succeed"
    assert not verify_password("wrong_password", hashed_password), "Verification of wrong password should fail"

def test_create_and_decode_access_token():
    """
    Testa a criação de um token de acesso JWT e sua decodificação.
    Verifica se:
    - Um token é gerado.
    - O token pode ser decodificado com sucesso.
    - O payload decodificado contém os dados esperados (subject, claims customizadas, expiração).
    - Tokens com tempo de expiração curto também funcionam.
    """
    payload_data = {"sub": "testuser@example.com", "custom_claim": "custom_value"}
    token = create_access_token(data=payload_data)
    assert token is not None
    assert isinstance(token, str)
    decoded_payload = decode_token(token)
    assert decoded_payload is not None
    assert decoded_payload.get("sub") == payload_data["sub"]
    assert decoded_payload.get("custom_claim") == payload_data["custom_claim"]
    assert "exp" in decoded_payload
    short_expires_delta = timedelta(seconds=1)
    short_lived_token = create_access_token(data=payload_data, expires_delta=short_expires_delta)
    decoded_short_lived_payload = decode_token(short_lived_token)
    assert decoded_short_lived_payload is not None

def test_create_and_decode_refresh_token() -> None:
    """
    Testa a criação de um refresh token JWT e sua decodificação.
    Verifica se:
    - Um token é gerado (usando a lógica de refresh token).
    - O token pode ser decodificado com sucesso.
    - O payload decodificado contém o subject esperado e uma expiração.
    """
    payload_data: Dict[str, Any] = {"sub": "refresh_user@example.com"}
    token = create_refresh_token(data=payload_data)

    assert token is not None
    assert isinstance(token, str)

    decoded_payload = decode_token(token)
    assert decoded_payload is not None, "Refresh token should be decodable"
    assert decoded_payload.get("sub") == payload_data["sub"], "Subject in refresh token mismatch"
    assert "exp" in decoded_payload, "Expiration claim 'exp' should be in refresh token"

    short_expires_delta = timedelta(seconds=1)
    short_lived_token = create_refresh_token(data=payload_data, expires_delta=short_expires_delta)
    decoded_short_lived_payload = decode_token(short_lived_token)
    assert decoded_short_lived_payload is not None, "Short-lived refresh token should be decodable"

def test_decode_and_get_subject_invalid_cases() -> None:
    """
    Testa a decodificação de tokens JWT inválidos e a extração de subject.
    Verifica se:
    - Um token com formato incorreto retorna None para decode_token e get_subject_from_token.
    - Um token assinado com uma chave secreta errada retorna None para ambos.
    - Um token válido mas sem a claim 'sub' retorna None para get_subject_from_token.
    - Um token válido mas com 'sub' de tipo incorreto (ex: int) retorna None para get_subject_from_token.
    """
    # 1. Token com formato inválido
    invalid_format_token = "this.is.not.a.valid.jwt"
    assert decode_token(invalid_format_token) is None, "Token with invalid format should not be decodable"
    assert get_subject_from_token(invalid_format_token) is None, "Subject from invalid format token should be None"

    # 2. Token com assinatura errada
    exp_time_minutes = (settings.ACCESS_TOKEN_EXPIRE_MINUTES if settings.ACCESS_TOKEN_EXPIRE_MINUTES else 30)
    payload_data_ok: Dict[str, Any] = { 
        "sub": "testuser@example.com",
        "exp": datetime.now(timezone.utc) + timedelta(minutes=exp_time_minutes)
    }
    wrong_secret_key = "not-" + settings.SECRET_KEY
    
    tampered_token = jwt.encode(payload_data_ok, wrong_secret_key, algorithm=settings.ALGORITHM)
    assert decode_token(tampered_token) is None, "Token with wrong signature should not be decodable"
    assert get_subject_from_token(tampered_token) is None, "Subject from tampered token should be None"

    # 3. Token válido, mas payload não contém 'sub'
    payload_no_sub: Dict[str, Any] = { 
        "another_claim": "value",
        "exp": datetime.now(timezone.utc) + timedelta(minutes=exp_time_minutes)
    }
    token_no_sub = jwt.encode(payload_no_sub, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    
    decoded_no_sub = decode_token(token_no_sub)
    assert decoded_no_sub is not None
    assert decoded_no_sub.get("another_claim") == "value"
    assert get_subject_from_token(token_no_sub) is None, "Subject from token without 'sub' claim should be None"

    # 4. Token válido, 'sub' não é uma string
    payload_sub_not_string: Dict[str, Any] = { 
        "sub": 12345,
        "exp": datetime.now(timezone.utc) + timedelta(minutes=exp_time_minutes)
    }
    token_sub_not_string = jwt.encode(payload_sub_not_string, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    
    decoded_sub_not_string = decode_token(token_sub_not_string)
    assert decoded_sub_not_string is None, "Token with non-string 'sub' should fail decoding (return None)"
    assert get_subject_from_token(token_sub_not_string) is None, "Subject from token with non-string 'sub' (which failed decoding) should be None"

================================================================================
Capítulo 32: backend\tests\crud\test_user_crud.py
================================================================================

# tests/crud/test_user_crud.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from sqlalchemy.orm import Session
from typing import Dict, Any

from app.crud import user as crud_user
from app.schemas.user import UserCreate, UserUpdate
from app.core.security import verify_password

# =======================================================================================================
# --- Testes para CRUD de Usuário ---                                                               #####
# =======================================================================================================

def test_create_user(db_session: Session) -> None:
    """
    Testa a criação de um novo usuário no banco de dados.
    Verifica se:
    - O usuário é criado com os dados corretos.
    - A senha é armazenada com hash.
    - Os valores padrão para 'is_active' e 'is_superuser' são aplicados.
    """
    user_email = "test_create@example.com"
    user_password = "testpassword123"
    user_full_name = "Test Create User"

    user_in = UserCreate(
        email=user_email,
        password=user_password,
        full_name=user_full_name
    )

    db_user = crud_user.create_user(db=db_session, user=user_in)

    assert db_user is not None, "A criação do usuário deve retornar um objeto usuário."
    assert db_user.email == user_email, "O email do usuário criado não corresponde."
    assert db_user.full_name == user_full_name, "O nome completo do usuário criado não corresponde."
    assert hasattr(db_user, "hashed_password"), "O usuário criado deve ter uma senha com hash."
    assert db_user.hashed_password != user_password, "A senha com hash não deve ser igual à senha plana."
    assert verify_password(user_password, db_user.hashed_password), "A senha plana deve ser verificável contra o hash."
    assert db_user.is_active is True, "O usuário deve ser ativo por padrão."
    assert db_user.is_superuser is False, "O usuário não deve ser superusuário por padrão."
    assert db_user.id is not None, "O usuário criado deve ter um ID atribuído pelo banco."


def test_get_user_by_email(db_session: Session) -> None:
    """
    Testa a recuperação de um usuário pelo seu endereço de e-mail.
    Verifica se:
    - Um usuário existente é retornado corretamente.
    - None é retornado para um e-mail não existente.
    """
    user_email = "get_by_email@example.com"
    user_password = "testpassword123"
    user_in_create = UserCreate(email=user_email, password=user_password)
    created_user = crud_user.create_user(db=db_session, user=user_in_create)

    retrieved_user = crud_user.get_user_by_email(db=db_session, email=user_email)
    assert retrieved_user is not None, "Deve encontrar o usuário pelo e-mail."
    assert retrieved_user.id == created_user.id, "O ID do usuário recuperado não corresponde."
    assert retrieved_user.email == user_email, "O email do usuário recuperado não corresponde."

    non_existent_user = crud_user.get_user_by_email(db=db_session, email="nonexistent@example.com")
    assert non_existent_user is None, "Não deve encontrar um usuário com e-mail não existente."


def test_get_user_by_id(db_session: Session) -> None:
    """
    Testa a recuperação de um usuário pelo seu ID.
    Verifica se:
    - Um usuário existente é retornado corretamente pelo ID.
    - None é retornado para um ID não existente.
    """
    user_email = "get_by_id@example.com"
    user_password = "testpassword123"
    user_in_create = UserCreate(email=user_email, password=user_password)
    created_user = crud_user.create_user(db=db_session, user=user_in_create)

    assert created_user.id is not None, "Usuário criado deve ter um ID."

    retrieved_user = crud_user.get_user(db=db_session, user_id=created_user.id)
    assert retrieved_user is not None, "Deve encontrar o usuário pelo ID."
    assert retrieved_user.id == created_user.id, "O ID do usuário recuperado não corresponde."
    assert retrieved_user.email == user_email, "O email do usuário recuperado não corresponde."

    non_existent_user = crud_user.get_user(db=db_session, user_id=999999)
    assert non_existent_user is None, "Não deve encontrar um usuário com ID não existente."

def test_update_user_all_fields(db_session: Session) -> None:
    """
    Testa a atualização de todos os campos permitidos de um usuário, incluindo a senha.
    """
    original_email = "update_me@example.com"
    original_password = "oldPassword123"
    original_full_name = "Original Name"
    user_to_update = crud_user.create_user(db_session, UserCreate(
        email=original_email, password=original_password, full_name=original_full_name,
        is_active=True, is_superuser=False
    ))

    new_email = "updated_email@example.com"
    new_password = "newStrongPassword456"
    new_full_name = "Updated Full Name"
    update_data = UserUpdate(
        email=new_email,
        password=new_password,
        full_name=new_full_name,
        is_active=False,
        is_superuser=True
    )

    updated_user = crud_user.update_user(db=db_session, db_user=user_to_update, user_in=update_data)

    assert updated_user is not None
    assert updated_user.id == user_to_update.id
    assert updated_user.email == new_email
    assert updated_user.full_name == new_full_name
    assert updated_user.is_active is False
    assert updated_user.is_superuser is True
    assert verify_password(new_password, updated_user.hashed_password)
    assert not verify_password(original_password, updated_user.hashed_password)


def test_update_user_partial_no_password(db_session: Session) -> None:
    """
    Testa a atualização parcial de um usuário (ex: apenas nome), sem alterar a senha.
    """
    email = "partial_update@example.com"
    password = "passwordUnchanged"
    user_to_update = crud_user.create_user(db_session, UserCreate(
        email=email, password=password, full_name="Initial Name"
    ))

    new_full_name = "Partially Updated Name"
    update_data_dict: Dict[str, Any] = {
        "full_name": new_full_name, 
        "is_active": False        
    } 

    updated_user = crud_user.update_user(db=db_session, db_user=user_to_update, user_in=update_data_dict)

    assert updated_user is not None
    assert updated_user.email == email 
    assert updated_user.full_name == new_full_name
    assert updated_user.is_active is False
    assert verify_password(password, updated_user.hashed_password)


def test_update_user_only_password(db_session: Session) -> None:
    """Testa a atualização apenas da senha de um usuário."""
    email = "password_only_update@example.com"
    original_password = "originalPassword"
    user_to_update = crud_user.create_user(db_session, UserCreate(
        email=email, password=original_password, full_name="Password User"
    ))

    new_password = "newSecurePasswordOnly"
    update_data = UserUpdate(password=new_password)

    updated_user = crud_user.update_user(db=db_session, db_user=user_to_update, user_in=update_data)

    assert updated_user is not None
    assert updated_user.email == email
    assert verify_password(new_password, updated_user.hashed_password)
    assert not verify_password(original_password, updated_user.hashed_password)


def test_update_user_with_none_values(db_session: Session) -> None:
    """
    Testa que campos não enviados (que são None no Pydantic model se não definidos)
    não sobrescrevem valores existentes para None na função de update.
    A lógica atual do crud.update_user é:
    `if hasattr(db_user, field) and value is not None: setattr(db_user, field, value)`
    Então, se passarmos `None` explicitamente para um campo que pode ser `None` no UserUpdate
    (como `full_name`), ele não deveria ser atualizado para `None`.
    Para "limpar" um campo (setar para None), precisaríamos de lógica adicional
    ou passar um valor específico como uma string vazia.
    Este teste verifica que campos 'não preenchidos' no update não mudam o valor do DB.
    """
    email = "none_values_update@example.com"
    initial_full_name = "Initial Full Name"
    user_to_update = crud_user.create_user(db_session, UserCreate(
        email=email, password="password", full_name=initial_full_name
    ))

    update_data_schema = UserUpdate() 
    updated_user = crud_user.update_user(db=db_session, db_user=user_to_update, user_in=update_data_schema)

    assert updated_user.full_name == initial_full_name, "full_name não deveria mudar para None se não enviado."
    assert updated_user.email == email, "email não deveria mudar para None se não enviado."

    update_data_dict = {"full_name": None}
    updated_user_dict = crud_user.update_user(db=db_session, db_user=user_to_update, user_in=update_data_dict)
    assert updated_user_dict.full_name == initial_full_name, \
        "full_name não deveria ser setado para None explicitamente devido à condição 'value is not None'."


def test_delete_user(db_session: Session) -> None:
    """
    Testa a exclusão de um usuário do banco de dados.
    """
    email_to_delete = "delete_me@example.com"
    user_to_delete_in_create = UserCreate(email=email_to_delete, password="password")
    user_to_delete_model = crud_user.create_user(db=db_session, user=user_to_delete_in_create) 

    assert user_to_delete_model.id is not None
    user_id_deleted = user_to_delete_model.id

    deleted_user_obj = crud_user.delete_user(db=db_session, db_user=user_to_delete_model)

    assert deleted_user_obj.id == user_id_deleted 

    user_after_delete = crud_user.get_user(db=db_session, user_id=user_id_deleted)
    assert user_after_delete is None, "Usuário não deveria ser encontrado no banco após a exclusão."

    user_by_email_after_delete = crud_user.get_user_by_email(db=db_session, email=email_to_delete)
    assert user_by_email_after_delete is None, "Usuário não deveria ser encontrado por e-mail após a exclusão."

================================================================================
Capítulo 33: backend\tests\schemas\test_token_schema.py
================================================================================

# tests/schemas/test_token_schema.py

# =======================================================================================================
# --- Importações ---                                                                               #####
# =======================================================================================================

from pydantic import ValidationError
import pytest

from app.schemas.token import TokenData # Ou de onde você importa TokenData nos seus testes

# =======================================================================================================
# --- Teste ---                                                                                     #####
# =======================================================================================================

def test_tokendata_email_validation():
    """Testa se TokenData levanta ValidationError para um email inválido."""
    with pytest.raises(ValidationError):
        TokenData(email="not-an-email") # Deve levantar ValidationError

    # Teste com um email válido para garantir que funciona
    try:
        valid_td = TokenData(email="valid@example.com")
        assert valid_td.email == "valid@example.com"
    except ValidationError:
        pytest.fail("TokenData não deveria levantar ValidationError para um email válido.")

    # Teste com None (que é permitido pelo schema Optional[str])
    try:
        none_td = TokenData(email=None)
        assert none_td.email is None
    except ValidationError:
        pytest.fail("TokenData não deveria levantar ValidationError para email=None.")

================================================================================
Capítulo 34: backend\tests\utils\user.py
================================================================================

# backend/tests/utils/user.py
from typing import Dict
from sqlalchemy.orm import Session
from fastapi.testclient import TestClient
import random
import string

from app.core.config import settings
from app.schemas.user import UserCreate
from app.crud import user as crud_user
from app.db.models.user import User as UserModel 

def random_lower_string(length: int = 32) -> str:
    return "".join(random.choices(string.ascii_lowercase, k=length))

def random_email() -> str:
    return f"{random_lower_string()}@{random_lower_string(6)}.com"

def create_random_user(db: Session, is_superuser: bool = False, is_active: bool = True) -> UserModel:
    email = random_email()
    password = random_lower_string(8)
    full_name = random_lower_string(10)
    user_in = UserCreate(email=email, password=password, full_name=full_name, is_superuser=is_superuser, is_active=is_active)
    user_obj = crud_user.create_user(db=db, user=user_in) 
    return user_obj

def authentication_token_from_email(
    *, client: TestClient, email: str, password: str
) -> Dict[str, str]:
    data = {"username": email, "password": password}
    r = client.post(f"{settings.API_V1_STR}/auth/login", data=data)
    response = r.json()
    auth_token = response["access_token"]
    headers = {"Authorization": f"Bearer {auth_token}"}
    return headers



================================================================================
Capítulo 35: docker-compose.yml
================================================================================

# /docker-compose.yml

# =======================================================================================================
# --- Definição dos Serviços ---                                                                    #####
# =======================================================================================================
services:
  # =======================================================================================================
  # --- Serviço do Banco de Dados (PostgreSQL) ---                                                  #####
  # =======================================================================================================
  db:
    image: postgis/postgis:16-3.4
    container_name: agro-db
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-agro_user}       
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-agro_password} 
      POSTGRES_DB: ${POSTGRES_DB:-agro_db}           
    volumes:
      - postgres_data:/var/lib/postgresql/data  
    ports:
      - "${DB_PORT:-5432}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-agro_user} -d ${POSTGRES_DB:-agro_db}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # =======================================================================================================
  # --- Serviço do Backend (FastAPI) ---                                                              #####
  # =======================================================================================================
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: agro-backend
    env_file:
      - ./backend/.env
    ports:
      - "${BACKEND_PORT:-8000}:8000" 
    depends_on:
      db:
        condition: service_healthy 
    command: /app/entrypoint.sh
    restart: unless-stopped

  # =======================================================================================================
  # --- Serviço do Frontend (Vue.js com Vite) ---                                                   #####
  # =======================================================================================================
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: agro-frontend
    ports:
      - "${FRONTEND_PORT:-5173}:5173" 
    environment:
      - VITE_API_BASE_URL=http://localhost:${BACKEND_PORT:-8000}${API_V1_STR:-/api/v1}
      - CHOKIDAR_USEPOLLING=true
    depends_on:
      - backend 
    restart: unless-stopped

# =======================================================================================================
# --- Definição de Volumes ---                                                                      #####
# =======================================================================================================
volumes:
  postgres_data: 
    driver: local


================================================================================
Capítulo 36: frontend\Dockerfile
================================================================================

# frontend/Dockerfile

# =======================================================================================================
# --- Estágio de Desenvolvimento ---                                                                #####
# =======================================================================================================
# Use uma imagem base oficial do Node.js. Alpine é uma boa escolha por ser leve.
FROM node:18-alpine AS development

# =======================================================================================================
# --- Diretório de Trabalho ---                                                                     #####
# =======================================================================================================
WORKDIR /app

# =======================================================================================================
# --- Instalação de Dependências ---                                                                #####
# =======================================================================================================
COPY package.json package-lock.json ./

# =======================================================================================================
# --- Permissões para o Usuário ---                                                                #####
# =======================================================================================================
RUN chown -R node:node /app
USER node
RUN npm ci

# =======================================================================================================
# --- Copiando Código da Aplicação ---                                                              #####
# =======================================================================================================
COPY --chown=node:node . .

# =======================================================================================================
# --- Exposição de Porta ---                                                                        #####
# =======================================================================================================
EXPOSE 5173

# =======================================================================================================
# --- Comando de Execução ---                                                                       #####
# =======================================================================================================
CMD ["npm", "run", "dev"]

# =======================================================================================================
# --- NOTA PARA PRODUÇÃO ---                                                                        #####
# =======================================================================================================
# Este Dockerfile é otimizado para DESENVOLVIMENTO com hot-reloading.
# Para PRODUÇÃO, você usaria um build multi-stage:
# 1. Um estágio 'builder' similar a este para rodar `npm run build`.
# 2. Um segundo estágio final usando uma imagem leve de servidor web (ex: nginx:alpine)
#    para copiar os artefatos da build (do diretório 'dist') e servi-los estaticamente.
# =======================================================================================================


================================================================================
Capítulo 37: frontend\env.d.ts
================================================================================

/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_BASE_URL: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}

================================================================================
Capítulo 38: frontend\eslint.config.ts
================================================================================

import { globalIgnores } from 'eslint/config'
import { defineConfigWithVueTs, vueTsConfigs } from '@vue/eslint-config-typescript'
import pluginVue from 'eslint-plugin-vue'
import skipFormatting from '@vue/eslint-config-prettier/skip-formatting'

// To allow more languages other than `ts` in `.vue` files, uncomment the following lines:
// import { configureVueProject } from '@vue/eslint-config-typescript'
// configureVueProject({ scriptLangs: ['ts', 'tsx'] })
// More info at https://github.com/vuejs/eslint-config-typescript/#advanced-setup

export default defineConfigWithVueTs(
  {
    name: 'app/files-to-lint',
    files: ['**/*.{ts,mts,tsx,vue}'],
  },

  globalIgnores(['**/dist/**', '**/dist-ssr/**', '**/coverage/**']),

  pluginVue.configs['flat/essential'],
  vueTsConfigs.recommended,
  skipFormatting,
)


================================================================================
Capítulo 39: frontend\package.json
================================================================================

{
  "name": "vue-crud-template",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite --host 0.0.0.0 --port 5173",
    "build": "run-p type-check \"build-only {@}\" --",
    "preview": "vite preview",
    "build-only": "vite build",
    "type-check": "vue-tsc --build",
    "lint": "eslint . --fix",
    "format": "prettier --write src/"
  },
  "dependencies": {
    "axios": "^1.9.0",
    "pinia": "^3.0.1",
    "vee-validate": "^4.15.0",
    "vue": "^3.5.13",
    "vue-router": "^4.5.0",
    "vue-toastification": "^2.0.0-rc.5",
    "yup": "^1.6.1"
  },
  "devDependencies": {
    "@tsconfig/node22": "^22.0.1",
    "@types/node": "^22.14.0",
    "@vitejs/plugin-vue": "^5.2.3",
    "@vue/eslint-config-prettier": "^10.2.0",
    "@vue/eslint-config-typescript": "^14.5.0",
    "@vue/tsconfig": "^0.7.0",
    "eslint": "^9.22.0",
    "eslint-plugin-vue": "~10.0.0",
    "jiti": "^2.4.2",
    "npm-run-all2": "^7.0.2",
    "prettier": "3.5.3",
    "typescript": "~5.8.0",
    "vite": "^6.2.4",
    "vite-plugin-vue-devtools": "^7.7.2",
    "vue-tsc": "^2.2.8"
  }
}


================================================================================
Capítulo 40: frontend\src\App.vue
================================================================================

<script setup lang="ts">
import { RouterLink, RouterView } from 'vue-router'
import { useAuthStore } from '@/stores/auth'
import { onMounted, computed, ref, watch } from 'vue'
import { useRoute } from 'vue-router'

const authStore = useAuthStore()
const route = useRoute()

const userDisplayName = computed(() => {
  if (authStore.currentUser) {
    return authStore.currentUser.full_name || authStore.currentUser.email
  }
  return ''
})

const isAdmin = computed(() => authStore.currentUser?.is_superuser || false)

const isMobileMenuOpen = ref(false)

const toggleMobileMenu = () => {
  isMobileMenuOpen.value = !isMobileMenuOpen.value
}

const closeMobileMenu = () => {
  isMobileMenuOpen.value = false
}

watch(
  () => route.path,
  () => {
    closeMobileMenu()
  },
)

onMounted(async () => {
  await authStore.tryAutoLogin()
})

const handleLogout = () => {
  closeMobileMenu()
  authStore.logout()
}
</script>

<template>
  <div class="app-layout">
    <header class="app-header">
      <div class="nav-container">
        <div class="logo-area">
          <RouterLink to="/" class="project-name" @click="closeMobileMenu"
            >Drone & Agro</RouterLink
          >
        </div>

        <button
          @click="toggleMobileMenu"
          class="mobile-menu-toggle"
          aria-label="Toggle menu"
          :aria-expanded="isMobileMenuOpen"
        >
          <span class="hamburger-icon">
            <span class="line line1"></span>
            <span class="line line2"></span>
            <span class="line line3"></span>
          </span>
        </button>

        <div class="navigation-wrapper" :class="{ 'is-open': isMobileMenuOpen }">
          <nav class="main-navigation">
            <RouterLink to="/" @click="closeMobileMenu">Home</RouterLink>
            <RouterLink to="/about" @click="closeMobileMenu">Sobre</RouterLink>
            <RouterLink v-if="isAdmin" to="/admin/users" class="admin-link" @click="closeMobileMenu"
              >Admin Usuários</RouterLink
            >
          </nav>
          <nav class="user-navigation">
            <template v-if="!authStore.isAuthenticated">
              <RouterLink to="/login" @click="closeMobileMenu">Login</RouterLink>
              <RouterLink to="/register" @click="closeMobileMenu">Registrar</RouterLink>
            </template>
            <template v-else>
              <span class="user-greeting">Olá, {{ userDisplayName }}!</span>
              <RouterLink to="/profile" @click="closeMobileMenu">Meu Perfil</RouterLink>
              <button @click="handleLogout" class="logout-button">Logout</button>
            </template>
          </nav>
        </div>
      </div>
    </header>

    <main class="main-content" @click="closeMobileMenu">
      <RouterView v-slot="{ Component }">
        <transition name="route-fade" mode="out-in">
          <component :is="Component" />
        </transition>
      </RouterView>
    </main>

    <footer class="app-footer">
      <p>© {{ new Date().getFullYear() }} Drone & Agro. Todos os direitos reservados.</p>
    </footer>
  </div>
</template>

<style scoped>
.app-layout {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  background-color: var(--bg-page);
}
.app-header {
  background-color: var(--bg-light);
  border-bottom: 1px solid var(--border-color);
  width: 100%;
  box-shadow: var(--box-shadow-light);
  line-height: 1.5;
  position: sticky;
  top: 0;
  z-index: 1020;
}

.nav-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 var(--mobile-padding);
  min-height: var(--header-height);
  position: relative;
  max-width: var(--content-max-width);
  margin: 0 auto;
}

.logo-area {
  margin-right: var(--padding-lg);
}
.project-name {
  margin: 15px;
  font-size: 1.5em;
  font-weight: 700;
  color: var(--text-color-primary);
  text-decoration: none;
}
.mobile-menu-toggle {
  display: none;
  background: none;
  border: none;
  cursor: pointer;
  padding: var(--padding-sm);
  z-index: 100;
}
.hamburger-icon {
  display: flex;
  flex-direction: column;
  justify-content: space-around;
  width: 24px;
  height: 20px;
}
.hamburger-icon .line {
  display: block;
  height: 3px;
  width: 100%;
  background-color: var(--primary-color);
  border-radius: 3px;
  transition: all 0.3s ease-in-out;
}

.navigation-wrapper.is-open ~ .mobile-menu-toggle .hamburger-icon .line1 {
  transform: rotate(45deg) translate(5px, 5px);
}
.navigation-wrapper.is-open ~ .mobile-menu-toggle .hamburger-icon .line2 {
  opacity: 0;
}
.navigation-wrapper.is-open ~ .mobile-menu-toggle .hamburger-icon .line3 {
  transform: rotate(-45deg) translate(6px, -6px);
}

.navigation-wrapper {
  display: flex;
  align-items: center;
  gap: var(--padding-md);
}

.main-navigation,
.user-navigation {
  display: flex;
  align-items: center;
  gap: var(--padding-sm);
  flex-wrap: wrap;
}

.main-navigation a,
.user-navigation a,
.user-navigation .user-greeting,
.user-navigation .logout-button {
  padding: var(--padding-sm) var(--padding-md);
  text-decoration: none;
  color: var(--primary-color);
  border-radius: var(--border-radius-md);
  transition:
    background-color 0.2s ease,
    color 0.2s ease;
  font-size: 0.95em;
  white-space: nowrap;
}
.main-navigation a:hover,
.user-navigation a:hover,
.user-navigation .logout-button:hover {
  background-color: var(--link-hover-bg);
  color: var(--primary-hover-color);
}
.main-navigation a.router-link-exact-active {
  background-color: var(--primary-color);
  color: var(--text-on-primary);
  font-weight: 600;
}
.main-navigation a.router-link-exact-active:hover {
  background-color: var(--primary-hover-color);
}
.admin-link {
  color: var(--admin-link-color) !important;
  font-weight: bold;
}
.admin-link:hover {
  background-color: var(--admin-link-hover-bg) !important;
  color: var(--color-text-primary) !important;
}
.admin-link.router-link-exact-active {
  background-color: var(--admin-link-hover-bg) !important;
  color: var(--color-text-primary) !important;
}
.user-greeting {
  color: var(--text-color-secondary);
  margin-right: var(--padding-sm);
  cursor: default;
  padding: var(--padding-sm) var(--padding-md);
}
.logout-button {
  background: none;
  border: 1px solid var(--danger-color);
  color: var(--danger-color);
  cursor: pointer;
}
.logout-button:hover {
  background-color: var(--danger-color) !important;
  color: var(--text-on-primary) !important;
}

.main-content {
  width: 100%;
  max-width: var(--content-max-width);
  margin: 25px auto;
  padding: 0 var(--mobile-padding);
  flex-grow: 1;
}
.route-fade-enter-active,
.route-fade-leave-active {
  transition: opacity 0.15s ease;
}
.route-fade-enter-from,
.route-fade-leave-to {
  opacity: 0;
}
.app-footer {
  text-align: center;
  padding: var(--padding-lg) var(--mobile-padding);
  background-color: var(--bg-dark);
  color: var(--text-on-dark-bg);
  font-size: 0.875em;
  width: 100%;
}

@media (max-width: 767.98px) {
  .mobile-menu-toggle {
    display: flex;
  }
  .nav-container {
    max-width: none;
    margin: 0;
  }
  .navigation-wrapper {
    display: none;
    flex-direction: column;
    align-items: flex-start;
    position: absolute;
    top: var(--header-height);
    left: 0;
    right: 0;
    background-color: var(--bg-light);
    padding: var(--padding-md) var(--padding-sm);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    border-top: 1px solid var(--border-color);
    z-index: 999;
  }
  .navigation-wrapper:not(.is-open) {
    display: none;
  }
  .navigation-wrapper.is-open {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    position: absolute;
    top: var(--header-height);
    left: 0;
    right: 0;
    background-color: var(--color-bg-light);
    padding: var(--padding-md) var(--mobile-padding);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    border-top: 1px solid var(--border-color);
    opacity: 0.95;
    z-index: 1000;
  }
  .main-navigation,
  .user-navigation {
    flex-direction: column;
    width: 100%;
    gap: 0;
    margin-bottom: 0;
    align-items: stretch;
  }
  .main-navigation a,
  .user-navigation a,
  .user-navigation .user-greeting,
  .user-navigation .logout-button {
    width: 100%;
    padding: var(--padding-md) var(--padding-sm);
    border-bottom: 1px solid var(--border-color);
    border-radius: 0;
  }
  .main-navigation a:last-child,
  .user-navigation a:last-child,
  .user-navigation .logout-button {
    border-bottom: none;
  }
  .user-actions-area {
    width: 100%;
  }
  .user-greeting {
    text-align: left;
  }
}

@media (min-width: 768px) {
  .nav-container {
    max-width: var(--content-max-width);
    margin: 0 auto;
    padding: 0 var(--desktop-padding);
    justify-content: flex-start;
  }
  .logo-area {
    margin-right: var(--padding-lg);
  }
  .navigation-wrapper {
    display: flex !important;
    flex-direction: row;
    position: static;
    background-color: transparent;
    padding: 0;
    box-shadow: none;
    border-top: none;
    width: auto;
    flex-grow: 1;
    justify-content: space-between;
  }
  .main-navigation {
    flex-direction: row;
    width: auto;
    margin-bottom: 0;
    gap: var(--padding-md);
  }
  .user-actions-area {
    margin-left: var(--padding-lg);
  }
  .user-navigation {
    flex-direction: row;
    width: auto;
    margin-bottom: 0;
    justify-content: flex-end;
    gap: var(--padding-sm);
  }
  .main-navigation a,
  .user-navigation a,
  .user-navigation .user-greeting,
  .user-navigation .logout-button {
    width: auto;
    padding: var(--padding-sm) var(--padding-md);
    border-bottom: none;
    border-radius: var(--border-radius-md);
  }
  .main-content {
    padding: 0 var(--desktop-padding);
    margin-top: 30px;
    margin-bottom: 30px;
  }
}

@media (min-width: 992px) {
  .project-name {
    font-size: 1.7em;
  }
  .main-navigation a,
  .user-navigation a,
  .user-navigation .user-greeting,
  .user-navigation .logout-button {
    font-size: 1em;
  }
}

@media (min-width: 1400px) {
  .project-name {
    font-size: 1.8em;
  }
  nav a,
  nav .user-greeting,
  nav .logout-button {
    padding: 10px 16px;
  }
}
@media (min-width: 1600px) {
  .project-name {
    font-size: 1.9em;
  }
}
</style>


================================================================================
Capítulo 41: frontend\src\main.ts
================================================================================

import './assets/main.css'

import { createApp } from 'vue'
import { createPinia } from 'pinia'
import Toast, { type PluginOptions, POSITION } from 'vue-toastification'
import 'vue-toastification/dist/index.css'

import App from './App.vue'
import router from './router'
import './assets/main.css';

const app = createApp(App)

// Opções para o Toast
const toastOptions: PluginOptions = {
  position: POSITION.TOP_RIGHT,
  timeout: 5000,
  closeOnClick: true,
  pauseOnFocusLoss: true,
  pauseOnHover: true,
  draggable: true,
  draggablePercent: 0.6,
  showCloseButtonOnHover: false,
  hideProgressBar: false,
  closeButton: 'button',
  icon: true,
  rtl: false,
  transition: 'Vue-Toastification__fade',
  maxToasts: 5,
  newestOnTop: true,
}

app.use(createPinia())
app.use(router)
app.use(Toast, toastOptions)

app.mount('#app')


================================================================================
Capítulo 42: frontend\src\router\index.ts
================================================================================

import { createRouter, createWebHistory } from 'vue-router'
import HomeView from '../views/HomeView.vue'
import LoginView from '../views/LoginView.vue'
import RegisterView from '../views/RegisterView.vue'
import ChangePasswordView from '../views/ChangePasswordView.vue'
import RequestPasswordRecoveryView from '../views/RequestPasswordRecoveryView.vue'
import ResetPasswordView from '../views/ResetPasswordView.vue'
import UserProfileView from '../views/UserProfileView.vue'
import AdminUsersListView from '../views/admin/AdminUsersListView.vue'
import AdminEditUsersView from '@/views/admin/AdminEditUsersView.vue'
const AdminCreateUserView = () => import('../views/admin/AdminCreateUserView.vue')

import { useAuthStore } from '@/stores/auth'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      name: 'home',
      component: HomeView,
    },
    {
      path: '/about',
      name: 'about',
      component: () => import('../views/AboutView.vue'),
    },
    {
      path: '/login',
      name: 'login',
      component: LoginView,
      meta: { guestOnly: true },
    },
    {
      path: '/register',
      name: 'register',
      component: RegisterView,
      meta: { guestOnly: true },
    },
    {
      path: '/change-password',
      name: 'change-password',
      component: ChangePasswordView,
      meta: { requiresAuth: true },
    },
    {
      path: '/forgot-password',
      name: 'forgot-password',
      component: RequestPasswordRecoveryView,
      meta: { guestOnly: true },
    },
    {
      path: '/reset-password',
      name: 'reset-password',
      component: ResetPasswordView,
      meta: { guestOnly: true },
    },
    {
      path: '/profile',
      name: 'profile',
      component: UserProfileView,
      meta: { requiresAuth: true },
    },
    {
      path: '/admin/users',
      name: 'admin-users',
      component: AdminUsersListView,
      meta: { requiresAuth: true, requiresAdmin: true },
    },
    {
      path: '/admin/users/edit/:id',
      name: 'admin-edit-user',
      component: AdminEditUsersView,
      meta: { requiresAuth: true, requiresAdmin: true },
      props: true,
    },
    {
      path: '/admin/users/create',
      name: 'admin-create-user',
      component: AdminCreateUserView,
      meta: { requiresAuth: true, requiresAdmin: true },
    },
  ],
})

router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore()

  if (
    authStore.token &&
    !authStore.user &&
    to.name !== 'login' &&
    to.name !== 'register' &&
    to.name !== 'forgot-password' &&
    to.name !== 'reset-password'
  ) {
    await authStore.tryAutoLogin()
  }

  const isAuthenticated = authStore.isAuthenticated
  const isSuperuser = authStore.currentUser?.is_superuser || false

  if (to.meta.requiresAuth && !isAuthenticated) {
    next({ name: 'login', query: { redirect: to.fullPath } })
  } else if (to.meta.requiresAdmin && (!isAuthenticated || !isSuperuser)) {
    console.warn('Acesso negado à rota de admin.')
    next({ name: 'home' })
  } else if (to.meta.guestOnly && isAuthenticated) {
    next({ name: 'home' })
  } else {
    next()
  }
})

export default router


================================================================================
Capítulo 43: frontend\src\services\apiService.ts
================================================================================

import axios from 'axios';
import { useAuthStore } from '../stores/auth';

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Interceptor para adicionar o token JWT a cada requisição
apiClient.interceptors.request.use(
  (config) => {
    const authStore = useAuthStore();
    const token = authStore.token;
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Interceptor para lidar com erros 401 (Não Autorizado)
// Opcional: pode ser útil para deslogar o usuário automaticamente se o token expirar
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      const authStore = useAuthStore();
      // Se não for uma requisição de login que falhou, deslogue
      if (!error.config.url.endsWith('/auth/login')) {
          authStore.logout();
          // Opcionalmente, redirecionar para a página de login
          // router.push('/login'); // Você precisará importar o router aqui
      }
    }
    return Promise.reject(error);
  }
);


export default apiClient;

================================================================================
Capítulo 44: frontend\src\stores\adminUsersStore.ts
================================================================================

import { defineStore } from 'pinia'
import apiClient from '@/services/apiService'
import type { UserRead, UserUpdate, UserCreate } from '@/types/user'
import { useToast } from 'vue-toastification'

const toast = useToast()

interface AdminUserState {
  user: UserRead | null
}

interface AdminUsersState {
  users: UserRead[]
  currentUserForEdit: UserRead | null
  isLoading: boolean
  isLoadingSingleUser: boolean
  error: string | null
  singleUserError: string | null
  totalUsers: number
  currentPage: number
  itemsPerPage: number
}

export const useAdminUsersStore = defineStore('adminUsers', {
  state: (): AdminUsersState => ({
    users: [],
    currentUserForEdit: null,
    isLoading: false,
    isLoadingSingleUser: false,
    error: null,
    singleUserError: null,
    totalUsers: 0,
    currentPage: 1,
    itemsPerPage: 100,
  }),
  getters: {
    allUsers: (state) => state.users,
    isLoadingUsers: (state) => state.isLoading,
    usersError: (state) => state.error,
    userForEdit: (state) => state.currentUserForEdit,
    isLoadingUserForEdit: (state) => state.isLoadingSingleUser,
    userForEditError: (state) => state.singleUserError,
  },
  actions: {
    _setLoading(loading: boolean) {
      this.isLoading = loading
    },
    _setError(error: string | null) {
      this.error = error
      if (error && !this.isLoadingSingleUser) {
        toast.error(error)
      }
    },
    _setUsers(users: UserRead[]) {
      this.users = users
    },
    _setPaginationDetails(total: number, page: number, limit: number) {
      this.totalUsers = total
      this.currentPage = page
      this.itemsPerPage = limit
    },
    _setCurrentUserForEdit(user: UserRead | null) {
      this.currentUserForEdit = user
    },
    _setLoadingSingleUser(loading: boolean) {
      this.isLoadingSingleUser = loading
    },
    _setSingleUserError(error: string | null) {
      this.singleUserError = error
      if (error) {
        toast.error(error)
      }
    },

    async fetchUsers(skip: number = 0, limit: number = 100) {
      this._setLoading(true)
      this._setError(null)
      try {
        const response = await apiClient.get<UserRead[]>(`/users/`, {
          params: { skip, limit },
        })
        this._setUsers(response.data)
      } catch (err: any) {
        console.error('Error fetching users:', err)
        const errorMessage = err.response?.data?.detail || 'Falha ao carregar usuários.'
        this._setError(errorMessage)
        this._setUsers([])
      } finally {
        this._setLoading(false)
      }
    },

    async fetchUserById(userId: number) {
      this._setLoadingSingleUser(true)
      this._setSingleUserError(null)
      this._setCurrentUserForEdit(null)
      try {
        const response = await apiClient.get<UserRead>(`/users/${userId}`)
        this._setCurrentUserForEdit(response.data)
        return response.data
      } catch (err: any) {
        console.error(`Error fetching user ${userId}:`, err)
        const errorMessage =
          err.response?.data?.detail || `Falha ao carregar usuário com ID ${userId}.`
        this._setSingleUserError(errorMessage)
        throw err
      } finally {
        this._setLoadingSingleUser(false)
      }
    },

    async deleteUser(userId: number) {
      this._setLoading(true)
      this._setError(null)
      try {
        await apiClient.delete(`/users/${userId}`)
        toast.success(`Usuário com ID ${userId} deletado com sucesso.`)
        this.users = this.users.filter((user) => user.id !== userId)
      } catch (err: any) {
        console.error(`Error deleting user ${userId}:`, err)
        const errorMessage =
          err.response?.data?.detail || `Falha ao deletar usuário com ID ${userId}.`
        this._setError(errorMessage)
      } finally {
        this._setLoading(false)
      }
    },

    async updateUserByAdmin(userId: number, updateData: UserUpdate) {
      this._setLoading(true)
      this._setError(null)
      try {
        const response = await apiClient.put<UserRead>(`/users/${userId}`, updateData)
        toast.success(`Usuário ID ${userId} atualizado com sucesso.`)
        const userIndex = this.users.findIndex((u) => u.id === userId)
        if (userIndex !== -1) {
          this.users[userIndex] = response.data
        }
        if (this.currentUserForEdit && this.currentUserForEdit.id === userId) {
          this._setCurrentUserForEdit(response.data)
        }
        return response.data
      } catch (err: any) {
        const errorMessage =
          err.response?.data?.detail || `Falha ao atualizar usuário ID ${userId}.`
        this._setError(errorMessage)
        throw err
      } finally {
        this._setLoading(false)
      }
    },

    async createUserByAdmin(userData: UserCreate) {
      this._setLoading(true)
      this._setError(null)
      try {
        const response = await apiClient.post<UserRead>(`/users/`, userData)
        toast.success(`Usuário ${response.data.email} criado com sucesso.`)
        this.users.unshift(response.data)
        return response.data
      } catch (err: any) {
        console.error('Error creating user (admin):', err)
        const errorMessage = err.response?.data?.detail || 'Falha ao criar usuário.'
        this._setError(errorMessage)
        throw err
      } finally {
        this._setLoading(false)
      }
    },
  },
})


================================================================================
Capítulo 45: frontend\src\stores\auth.ts
================================================================================

import { defineStore } from 'pinia'
import apiClient from '@/services/apiService'
import type {
  UserRead,
  UserCreate,
  UserPasswordChange,
  PasswordRecoveryRequest,
  PasswordResetForm,
  UserUpdate,
} from '@/types/user'
import type { Token } from '@/types/token'
import router from '@/router'
import { useToast } from 'vue-toastification'

const toast = useToast()

interface AuthState {
  user: UserRead | null
  token: string | null
  isAuthenticated: boolean
  error: string | null
  loading: boolean
}

export const useAuthStore = defineStore('auth', {
  state: (): AuthState => ({
    user: JSON.parse(localStorage.getItem('user') || 'null'),
    token: localStorage.getItem('token'),
    isAuthenticated: !!localStorage.getItem('token'),
    error: null,
    loading: false,
  }),
  getters: {
    currentUser: (state) => state.user,
  },
  actions: {
    setLoading(loading: boolean) {
      this.loading = loading
    },
    setError(error: string | null) {
      this.error = error
      if (error) {
        toast.error(error); 
      }
    },
    setToken(token: string | null) {
      this.token = token
      this.isAuthenticated = !!token
      if (token) {
        localStorage.setItem('token', token)
      } else {
        localStorage.removeItem('token')
      }
    },
    setUser(user: UserRead | null) {
      this.user = user
      if (user) {
        localStorage.setItem('user', JSON.stringify(user))
      } else {
        localStorage.removeItem('user')
      }
    },

    async login(credentials: { username: string; password: string }) {
      this.setLoading(true)
      this.setError(null)
      try {
        const formData = new FormData()
        formData.append('username', credentials.username)
        formData.append('password', credentials.password)

        const response = await apiClient.post<Token>('/auth/login', formData, {
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
        })

        const tokenData = response.data
        this.setToken(tokenData.access_token)
        await this.fetchCurrentUser()
        router.push('/')
        toast.success('Login bem-sucedido!')
      } catch (err: any) {
        console.error('Login error:', err)
        const errorMessage = err.response?.data?.detail || 'Falha ao fazer login. Verifique suas credenciais.'
        this.setError(errorMessage) 
        this.setToken(null)
        this.setUser(null)
      } finally {
        this.setLoading(false)
      }
    },

    async register(userData: UserCreate) {
      this.setLoading(true)
      this.setError(null)
      try {
        const response = await apiClient.post<UserRead>('/auth/register', userData)
        router.push('/login')
        toast.success('Registro bem-sucedido! Por favor, faça login.')
        return response.data
      } catch (err: any) {
        console.error('Register error:', err)
        const errorMessage = err.response?.data?.detail || 'Falha ao registrar. Tente novamente.'
        this.setError(errorMessage)
        throw err
      } finally {
        this.setLoading(false)
      }
    },

    async fetchCurrentUser() {
      this.setLoading(true)
      if (!this.token) {
        this.setUser(null)
        this.setLoading(false)
        return
      }
      try {
        const response = await apiClient.get<UserRead>('/auth/me')
        this.setUser(response.data)
      } catch (err: any) {
        console.error('Fetch current user error:', err)
        this.setUser(null)
        this.setToken(null)
        if (err.response && err.response.status === 401) {
          router.push('/login')
        }
      } finally {
        this.setLoading(false)
      }
    },

    logout() {
      this.setToken(null)
      this.setUser(null)
      localStorage.removeItem('token')
      localStorage.removeItem('user')
      router.push('/login')
      toast.info('Você foi desconectado.')
    },

    async tryAutoLogin() {
      if (this.token) {
        await this.fetchCurrentUser()
      }
    },

    async changePassword(passwordData: UserPasswordChange) {
      this.setLoading(true)
      this.setError(null)
      try {
        await apiClient.put('/auth/me/password', passwordData)
        toast.success('Senha alterada com sucesso!')
      } catch (err: any) {
        console.error('Change password error:', err)
        let errorMessage = 'Falha ao alterar a senha. Ocorreu um erro desconhecido.'
        if (err.response?.data?.detail) {
          if (typeof err.response.data.detail === 'string') {
            errorMessage = err.response.data.detail
          } else if (Array.isArray(err.response.data.detail) && err.response.data.detail[0]?.msg) {
            errorMessage = err.response.data.detail[0].msg
          } else {
            errorMessage = 'Falha ao alterar a senha. Verifique os dados fornecidos.'
          }
        } else if (err.message) {
          errorMessage = err.message
        }
        this.setError(errorMessage)
        throw err
      } finally {
        this.setLoading(false)
      }
    },

    async requestPasswordRecovery(email: string) {
      this.setLoading(true)
      this.setError(null)
      try {
        const recoveryData: PasswordRecoveryRequest = { email }
        const response = await apiClient.post<{ message: string }>(
          '/auth/password-recovery',
          recoveryData,
        )
        toast.info(response.data.message + " Em DEV, verifique os logs do backend para o token.")
        return response.data.message
      } catch (err: any) {
        console.error('Password recovery request error:', err)
        const errorMessage = err.response?.data?.detail || 'Ocorreu um erro ao solicitar a recuperação de senha.'
        this.setError(errorMessage)
        throw err
      } finally {
        this.setLoading(false)
      }
    },

    async resetPassword(resetData: PasswordResetForm) {
      this.setLoading(true)
      this.setError(null)
      try {
        await apiClient.post('/auth/reset-password', resetData)
        router.push('/login')
        toast.success('Senha redefinida com sucesso! Por favor, faça login com sua nova senha.')
      } catch (err: any) {
        console.error('Reset password error:', err)
        let errorMessage = 'Falha ao redefinir a senha. Tente novamente ou solicite um novo link.'
        if (err.response?.data?.detail) {
          if (typeof err.response.data.detail === 'string') {
            errorMessage = err.response.data.detail
          } else if (Array.isArray(err.response.data.detail) && err.response.data.detail[0]?.msg) {
            errorMessage = err.response.data.detail[0].msg
          } else {
            errorMessage = 'Falha ao redefinir a senha.'
          }
        }
        this.setError(errorMessage)
        throw err
      } finally {
        this.setLoading(false)
      }
    },

    async updateUserProfile(updateData: UserUpdate) {
      this.setLoading(true)
      this.setError(null)
      try {
        const response = await apiClient.patch<UserRead>('/auth/me', updateData)
        this.setUser(response.data)
        toast.success('Perfil atualizado com sucesso!')
        return response.data
      } catch (err: any) {
        console.error("Update profile error:", err)
        let errorMessage = 'Falha ao atualizar o perfil. Ocorreu um erro desconhecido.'
        if (err.response?.data?.detail) {
             if (typeof err.response.data.detail === 'string') {
                errorMessage = err.response.data.detail
            } else if (Array.isArray(err.response.data.detail) && err.response.data.detail[0]?.msg) {
                errorMessage = err.response.data.detail[0].msg
            } else {
                errorMessage = 'Falha ao atualizar o perfil.'
            }
        }
        this.setError(errorMessage)
        throw err
      } finally {
        this.setLoading(false)
      }
    },

    async deleteUserAccount() {
      this.setLoading(true)
      this.setError(null)
      try {
        await apiClient.delete('/auth/me')
        this.logout() 
        toast.success('Sua conta foi deletada com sucesso.')
      } catch (err: any) {
        console.error("Delete account error:", err)
        const errorMessage = err.response?.data?.detail || 'Falha ao deletar a conta. Tente novamente.'
        this.setError(errorMessage)
        throw err
      } finally {
        this.setLoading(false)
      }
    },
  },
})

================================================================================
Capítulo 46: frontend\src\stores\counter.ts
================================================================================

import { ref, computed } from 'vue'
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  const doubleCount = computed(() => count.value * 2)
  function increment() {
    count.value++
  }

  return { count, doubleCount, increment }
})


================================================================================
Capítulo 47: frontend\src\types\token.ts
================================================================================

export interface Token {
  access_token: string;
  token_type: string;
  refresh_token?: string | null;
}

export interface TokenData {
  email?: string | null;
}

================================================================================
Capítulo 48: frontend\src\types\user.ts
================================================================================

export interface UserBase {
  full_name?: string | null;
  is_active?: boolean;
  is_superuser?: boolean;
}

export interface UserCreate extends UserBase {
  email: string;
  password: string;
}

export interface UserRead extends UserBase {
  id: number;
  email: string;
  is_active: boolean; 
  is_superuser: boolean; 
}

export interface UserPasswordChange {
  current_password: string;
  new_password: string;
  new_password_confirm: string;
}

export interface PasswordRecoveryRequest {
  email: string;
}

export interface PasswordResetForm {
  token: string;
  new_password: string;
  new_password_confirm: string;
}

export interface UserUpdate {
  email?: string | null;       
  password?: string | null;    
  full_name?: string | null;
  is_active?: boolean;
  is_superuser?: boolean;
}

================================================================================
Capítulo 49: frontend\src\views\AboutView.vue
================================================================================

<template>
  <div class="view-card-container about-view-layout">
    <header class="about-header">
      <h1>Drone & Agro</h1>
      <p class="subtitle">
        Soluções tecnológicas e serviços especializados para o agronegócio.
      </p>
    </header>

    <section class="about-section">
      <h2>Objetivo</h2>
      <p class="objective-text">
        A Drone & Agro tem como missão fornecer serviços inovadores e de alta qualidade no setor agrícola, 
        com foco em mapeamento aéreo, pulverização de culturas, combate a pragas (como ervas daninhas e insetos), 
        manutenção de drones, reposição de peças e capacitação profissional. Atuamos para aumentar a eficiência, 
        sustentabilidade e produtividade no campo por meio da tecnologia.
      </p>
    </section>

    <section class="about-section">
      <h2>Serviços Oferecidos</h2>
      <ul>
        <li>Mapeamento agrícola por drones</li>
        <li>Pulverização agrícola automatizada</li>
        <li>Combate a ervas daninhas e insetos</li>
        <li>Manutenção corretiva e preventiva de drones</li>
        <li>Reposição de peças e acessórios para drones agrícolas</li>
        <li>Cursos de pilotagem de drones (com certificação)</li>
        <li>Capacitação para uso de defensivos agrícolas</li>
        <li>Treinamento técnico para manutenção de drones</li>
      </ul>
    </section>

    <section class="about-section">
      <h2>Tecnologias e Equipamentos</h2>
      <div class="tech-grid">
        <div class="tech-card">
          <h3>Drones Agrícolas</h3>
          <ul>
            <li><strong>DJI Agras T20, T30 e T40</strong></li>
            <li><strong>Autel EVO II Dual</strong></li>
            <li><strong>Drones customizados com RTK</strong></li>
          </ul>
        </div>
        <div class="tech-card">
          <h3>Sistemas & Software</h3>
          <ul>
            <li><strong>Software de planejamento de voo</strong></li>
            <li><strong>Processamento de imagens com IA</strong></li>
            <li><strong>Sistemas de telemetria em tempo real</strong></li>
          </ul>
        </div>
        <div class="tech-card">
          <h3>Capacitação & Certificação</h3>
          <ul>
            <li><strong>Instrutores certificados ANAC</strong></li>
            <li><strong>Material didático próprio</strong></li>
            <li><strong>Certificados válidos nacionalmente</strong></li>
          </ul>
        </div>
      </div>
    </section>

    <section class="about-section contact-info">
      <h2>Contato</h2>
      <p>
        Para orçamentos, agendamentos ou dúvidas, entre em contato conosco.
        <a
          href="https://www.instagram.com/brothersvideodrone?utm_source=ig_web_button_share_sheet&igsh=ZDNlZDc0MzIxNw=="
          target="_blank"
          rel="noopener noreferrer"
          class="btn btn-accent btn-inline"
        >
          Visite nosso Instagram!
        </a>
      </p>
    </section>
  </div>
</template>

<style scoped>
.about-view-layout {
  max-width: 900px;
  margin: var(--padding-xl) auto;
}
.about-header {
  text-align: center;
  margin-bottom: var(--padding-xl);
  padding-bottom: var(--padding-lg);
  border-bottom: 1px solid var(--color-border);
}
.about-header h1 {
  font-size: 2.2em;
  color: var(--color-brand-primary);
  margin-bottom: var(--padding-sm);
}
.subtitle {
  font-size: 1.1em;
  color: var(--color-text-secondary);
  font-family: var(--font-sans-ui);
}
.about-section {
  margin-bottom: var(--padding-xl);
}
.about-section h2 {
  font-size: 1.6em;
  color: var(--color-text-primary);
  margin-bottom: var(--padding-md);
  padding-bottom: var(--padding-sm);
  border-bottom: 2px solid var(--color-brand-secondary);
  display: inline-block;
}
.about-section h3 {
  font-size: 1.25em;
  font-family: var(--font-sans-ui);
  font-weight: 600;
  color: var(--color-text-primary);
  margin-top: var(--padding-lg);
  margin-bottom: var(--padding-sm);
}
.features-subtitle {
  margin-top: var(--padding-lg);
}
.objective-text,
.about-section p,
.about-section ul {
  font-size: 1rem;
  color: var(--color-text-secondary);
  margin-bottom: var(--padding-md);
  text-align: justify;
}
.about-section ul {
  list-style-position: inside;
  padding-left: 0;
}
.about-section ul li {
  margin-bottom: var(--padding-xs);
}
.tech-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: var(--padding-lg);
  margin-top: var(--padding-md);
}
.tech-card {
  background-color: var(--color-bg-page);
  padding: var(--padding-lg);
  border-radius: var(--border-radius-md);
  border: 1px solid var(--color-border);
}
.tech-card h3 {
  margin-top: 0;
  font-size: 1.15em;
  color: var(--color-brand-primary);
  border-bottom: none;
  padding-bottom: 0;
  margin-bottom: var(--padding-md);
}
.tech-card ul {
  font-size: 0.95rem;
  padding-left: var(--padding-md);
  color: var(--color-text-secondary);
}
.tech-card ul li strong {
  color: var(--color-text-primary);
}
.contact-info {
  text-align: center;
  padding-top: var(--padding-lg);
  border-top: 1px solid var(--color-border);
}
.contact-info p {
  text-align: center;
}
.btn.btn-inline {
  margin-left: var(--padding-sm);
}
</style>


================================================================================
Capítulo 50: frontend\src\views\ChangePasswordView.vue
================================================================================

<script setup lang="ts">
import { useAuthStore } from '@/stores/auth';
import type { UserPasswordChange } from '@/types/user';
import { Form, Field, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

const authStore = useAuthStore();

const validationSchema = yup.object({
  currentPassword: yup.string().required('A senha atual é obrigatória'),
  newPassword: yup.string()
    .required('A nova senha é obrigatória')
    .min(8, 'A nova senha deve ter pelo menos 8 caracteres')
    .notOneOf([yup.ref('currentPassword')], 'A nova senha não pode ser igual à senha atual'),
  newPasswordConfirm: yup.string()
    .required('A confirmação da nova senha é obrigatória')
    .oneOf([yup.ref('newPassword')], 'As novas senhas não coincidem'),
});

const initialValues = {
  currentPassword: '',
  newPassword: '',
  newPasswordConfirm: '',
};

const handleChangePassword = async (values: Record<string, any>, { setErrors, resetForm }: any) => {
  authStore.setError(null);

  const passwordData: UserPasswordChange = {
    current_password: values.currentPassword,
    new_password: values.newPassword,
    new_password_confirm: values.newPasswordConfirm,
  };

  try {
    await authStore.changePassword(passwordData);
    resetForm();
  } catch (error: any) {
    if (authStore.error) {
      setErrors({ apiError: authStore.error });
    } else if (error.response?.data?.detail) {
      const detail = error.response.data.detail;
      if (typeof detail === 'string') {
        setErrors({ apiError: detail });
      } else if (Array.isArray(detail) && detail[0]?.msg) {
        setErrors({ apiError: detail[0].msg });
      } else {
        setErrors({ apiError: 'Falha ao alterar a senha.' });
      }
    } else {
      setErrors({ apiError: 'Ocorreu um erro desconhecido ao tentar alterar a senha.' });
    }
    console.error('Erro ao alterar senha no componente:', error);
  }
};
</script>

<template>
  <div class="view-card-container change-password-layout">
    <h2>Alterar Senha</h2>
    <Form :validation-schema="validationSchema" :initial-values="initialValues" @submit="handleChangePassword" v-slot="{ errors, isSubmitting, meta }">
      <div class="form-group">
        <label for="currentPassword-change">Senha Atual:</label>
        <Field name="currentPassword" type="password" id="currentPassword-change" class="form-control" :class="{'is-invalid': errors.currentPassword }" />
        <ErrorMessage name="currentPassword" class="invalid-feedback" />
      </div>

      <div class="form-group">
        <label for="newPassword-change">Nova Senha:</label>
        <Field name="newPassword" type="password" id="newPassword-change" class="form-control" :class="{'is-invalid': errors.newPassword }" />
        <ErrorMessage name="newPassword" class="invalid-feedback" />
      </div>

      <div class="form-group">
        <label for="newPasswordConfirm-change">Confirmar Nova Senha:</label>
        <Field name="newPasswordConfirm" type="password" id="newPasswordConfirm-change" class="form-control" :class="{'is-invalid': errors.newPasswordConfirm }" />
        <ErrorMessage name="newPasswordConfirm" class="invalid-feedback" />
      </div>

      <div v-if="errors.apiError" class="api-error-message form-feedback">
        {{ errors.apiError }}
      </div>
      <div v-else-if="authStore.error && !meta.dirty && meta.touched && !errors.apiError" class="api-error-message form-feedback">
         {{ authStore.error }}
      </div>

      <button type="submit" :disabled="isSubmitting || authStore.loading || !meta.valid && meta.touched" class="btn btn-primary btn-block">
        {{ (isSubmitting || authStore.loading) ? 'Alterando...' : 'Alterar Senha' }}
      </button>
    </Form>
  </div>
</template>

<style scoped>
.change-password-layout {
  max-width: 480px;
  margin: var(--padding-xl) auto;
}
.change-password-layout h2 {
  text-align: center;
  margin-bottom: var(--padding-lg);
  color: var(--color-text-primary);
}
.btn-block {
  width: 100%;
  margin-top: var(--padding-md);
}
</style>


================================================================================
Capítulo 51: frontend\src\views\HomeView.vue
================================================================================

<script setup lang="ts">
import { useAuthStore } from '@/stores/auth'
import iconeMapeamento from '@/assets/images/photogrammetry.png'
import iconeDefensivos from '@/assets/images/fertilizer.png'
import iconePragas from '@/assets/images/fumigator.png'
import iconeManutencao from '@/assets/images/customer-service.png'
import iconeContato from '@/assets/images/help-desk.png'
import iconeCertificacoes from '@/assets/images/education.png'

const authStore = useAuthStore()

const handleMapeamentoClick = () => console.log('Mapeamento Clicado')
const handleDefensivosClick = () => console.log('Defensivos Clicado')
const handlePragasClick = () => console.log('Pragas Clicado')
const handleManutencaoClick = () => console.log('Manutencao Clicado')
const handleContatoClick = () => console.log('Contato Clicado')
const handleCertificacoesClick = () => console.log('Certificacoes Clicado')

</script>

<template>
  <div class="view-card-container home-view-layout">
    <div class="button-row top-button-row">
      <button class="action-button" @click="handleMapeamentoClick" aria-label="Mapeamento de Área">
        <img :src="iconeMapeamento" alt="" class="button-icon" />
        <span class="button-text">Mapeamento de Área</span>
      </button>
      <button class="action-button" @click="handleDefensivosClick" aria-label="Aplicação de Defensivos">
        <img :src="iconeDefensivos" alt="" class="button-icon" />
        <span class="button-text">Aplicação de Defensivos</span>
      </button>
      <button class="action-button" @click="handlePragasClick" aria-label="Combate a Pragas">
        <img :src="iconePragas" alt="" class="button-icon" />
        <span class="button-text">Combate a Pragas</span>
      </button>
    </div>
    <section class="hero-section" :class="{ 'logged-in-hero': authStore.isAuthenticated }">
      <div class="hero-content">
        <!-- Conteúdo sobreposto à imagem (se necessário) -->
      </div>
    </section>
    <div class="button-row bottom-button-row">
      <button class="action-button" @click="handleManutencaoClick" aria-label="Manutenção e Peças">
        <img :src="iconeManutencao" alt="" class="button-icon" />
        <span class="button-text">Manutenção e Peças</span>
      </button>
      <button class="action-button" @click="handleContatoClick" aria-label="Contato">
        <img :src="iconeContato" alt="" class="button-icon" />
        <span class="button-text">Contato</span>
      </button>
      <button class="action-button" @click="handleCertificacoesClick" aria-label="Certificações">
        <img :src="iconeCertificacoes" alt="" class="button-icon" />
        <span class="button-text">Certificações</span>
      </button>
    </div>
  </div>
</template>

<style scoped>
.home-view-layout {
  max-width: 100%;
  padding: 0;
  box-shadow: none;
  background-color: transparent;
  margin: 0;
  height: calc(80vh - var(--header-height, 60px) - var(--footer-height, 78px));
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.button-row {
  display: flex;
  gap: var(--padding-md, 16px);
  justify-content: space-around;
  align-items: stretch;
  width: 70%;
  max-width: 700px;
  padding: var(--padding-xs, 8px) 0;
}

.top-button-row {
  margin-bottom: var(--padding-md, 16px);
}

.bottom-button-row {
  margin-top: var(--padding-md, 16px);
}

.action-button {
  flex: 1;
  padding: var(--padding-md, 16px);
  background-color: var(--primary-color, #009bff);
  color: var(--text-on-primary, white);
  border: none;
  border-radius: var(--border-radius-lg, 8px);
  cursor: pointer;
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  transition: background-color 0.3s ease;
  font-weight: 500;
  box-shadow: var(--box-shadow, 0 2px 4px rgba(0, 0, 0, 0.1));
  min-width: 100px;
}

.action-button:active {
  transform: translateY(-1px);
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.button-icon {
  width: 48px;
  height: 48px;
  object-fit: contain;
}

.button-text {
  font-size: clamp(0.8rem, 2.5vw, 0.95em);
  line-height: 1.3;
  word-break: break-word;
  display: block;
  max-width: 100%;
}

.hero-section {
  background-image: url('@/assets/images/agromaping.png');
  background-size: 50%;
  background-repeat: no-repeat;
  background-position: center center;
  width: 70%;
  max-width: 700px;
  min-height: 30vh;
  display: flex;
  justify-content: center;
  align-items: center;
  border-radius: var(--border-radius-lg, 8px);
  margin: 0;
  position: relative;
  overflow: hidden;
}

.hero-content {
  display: none;
}

@media (max-width: 992px) {

  .button-row,
  .hero-section {
    width: 85%;
    max-width: none;
  }

  .action-button {
    min-height: 110px;
    gap: var(--padding-xxs, 4px);
  }

  .button-icon {
    width: 40px;
    height: 40px;
  }
}


@media (max-width: 768px) {
  .home-view-layout {
    justify-content: flex-start;
    padding-top: var(--padding-md, 16px);
    height: auto;
    min-height: calc(100vh - var(--header-height, 60px) - var(--footer-height, 78px));
  }

  .button-row,
  .hero-section {
    width: 95%;
    gap: var(--padding-sm, 8px);
  }

  .action-button {
    min-height: 100px;
    padding: var(--padding-sm, 12px);
  }

  .button-icon {
    width: 36px;
    height: 36px;
  }

  .button-text {
    font-size: 0.85em;
  }

  .hero-section {
    background-size: 65%;
    min-height: 25vh;
  }
}

@media (max-width: 480px) {
  .button-row {
    flex-direction: column;
    width: 90%;
    gap: var(--padding-md, 16px);
  }

  .action-button {
    flex-basis: auto;
    width: 100%;
    min-height: 90px;
  }

  .hero-section {
    min-height: 20vh;
    width: 90%;
    background-size: 70%;
  }
}
</style>

================================================================================
Capítulo 52: frontend\src\views\LoginView.vue
================================================================================

<script setup lang="ts">
import { useAuthStore } from '@/stores/auth';
import { useRouter } from 'vue-router';
import { Form, Field, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

const authStore = useAuthStore();
const router = useRouter();

const validationSchema = yup.object({
  email: yup.string().required('O email é obrigatório').email('Formato de email inválido'),
  password: yup.string().required('A senha é obrigatória'),
});

const initialValues = {
  email: '',
  password: '',
};

const handleLogin = async (values: Record<string, any>, { setErrors }: any) => {
  authStore.setError(null);
  try {
    await authStore.login({ username: values.email, password: values.password });
    if (authStore.isAuthenticated) {
      router.push('/');
    } else if (authStore.error) {
      setErrors({ apiError: authStore.error });
    }
  } catch (error: any) {
    if (authStore.error) {
        setErrors({ apiError: authStore.error });
    } else if (error.message){
        setErrors({ apiError: error.message });
    } else {
        setErrors({ apiError: 'Ocorreu um erro inesperado.' });
    }
    console.error('Falha no login do componente:', error);
  }
};
</script>

<template>
  <div class="view-card-container login-view-layout">
    <h2>Login</h2>
    <Form :validation-schema="validationSchema" :initial-values="initialValues" @submit="handleLogin" v-slot="{ errors, isSubmitting }">
      <div class="form-group">
        <label for="email-login">Email:</label>
        <Field name="email" type="email" id="email-login" class="form-control" :class="{'is-invalid': errors.email }" />
        <ErrorMessage name="email" class="invalid-feedback" />
      </div>

      <div class="form-group">
        <label for="password-login">Senha:</label>
        <Field name="password" type="password" id="password-login" class="form-control" :class="{'is-invalid': errors.password }" />
        <ErrorMessage name="password" class="invalid-feedback" />
      </div>

      <div v-if="errors.apiError" class="api-error-message form-feedback">
        {{ errors.apiError }}
      </div>
      <div v-else-if="authStore.error && !errors.apiError" class="api-error-message form-feedback">
         {{ authStore.error }}
      </div>

      <button type="submit" :disabled="isSubmitting || authStore.loading" class="btn btn-primary btn-block">
        {{ (isSubmitting || authStore.loading) ? 'Entrando...' : 'Entrar' }}
      </button>
    </Form>
    <p class="form-link-center">
      <router-link to="/forgot-password">Esqueci minha senha</router-link>
    </p>
    <p class="form-link-center">
      Não tem uma conta? <router-link to="/register">Registre-se</router-link>
    </p>
  </div>
</template>

<style scoped>
.login-view-layout {
  max-width: 420px;
  margin: var(--padding-xl) auto;
}
.login-view-layout h2 {
  text-align: center;
  margin-bottom: var(--padding-lg);
  font-size: 2em;
  color: var(--color-text-primary);
}
.btn-block {
  width: 100%;
  margin-top: var(--padding-md);
}
.form-link-center {
  text-align: center;
  margin-top: var(--padding-lg);
  font-size: 0.9rem;
  font-family: var(--font-sans-ui);
  color: var(--color-text-secondary);
}
.form-link-center a {
  font-weight: 600;
  color: var(--color-text-link);
}
.form-link-center a:hover {
  color: var(--color-text-link-hover);
}
</style>


================================================================================
Capítulo 53: frontend\src\views\RegisterView.vue
================================================================================

<script setup lang="ts">
import { useAuthStore } from '@/stores/auth';
import type { UserCreate } from '@/types/user';
import { Form, Field, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

const authStore = useAuthStore();

const validationSchema = yup.object({
  email: yup.string().required('O email é obrigatório').email('Formato de email inválido'),
  fullName: yup.string().nullable(),
  password: yup.string().required('A senha é obrigatória').min(8, 'A senha deve ter pelo menos 8 caracteres'),
  confirmPassword: yup.string()
    .required('A confirmação de senha é obrigatória')
    .oneOf([yup.ref('password')], 'As senhas não coincidem'),
});

const initialValues = {
  email: '',
  fullName: '',
  password: '',
  confirmPassword: '',
};

const handleRegister = async (values: Record<string, any>, { setErrors }: any) => {
  authStore.setError(null);

  const userData: UserCreate = {
    email: values.email,
    password: values.password,
    full_name: values.fullName || null,
  };

  try {
    await authStore.register(userData);
  } catch (error: any) {
    if (error.response && error.response.data && error.response.data.detail) {
      setErrors({ apiError: error.response.data.detail });
    } else {
      setErrors({ apiError: 'Falha ao registrar. Tente novamente.' });
    }
    console.error('Falha no registro do componente:', error);
  }
};
</script>

<template>
  <div class="view-card-container register-view-layout">
    <h2>Registrar</h2>
    <Form :validation-schema="validationSchema" :initial-values="initialValues" @submit="handleRegister" v-slot="{ errors, isSubmitting }">
      <div class="form-group">
        <label for="email-register">Email:</label>
        <Field name="email" type="email" id="email-register" class="form-control" :class="{'is-invalid': errors.email }" />
        <ErrorMessage name="email" class="invalid-feedback" />
      </div>

      <div class="form-group">
        <label for="fullName-register">Nome Completo (Opcional):</label>
        <Field name="fullName" type="text" id="fullName-register" class="form-control" :class="{'is-invalid': errors.fullName }" />
        <ErrorMessage name="fullName" class="invalid-feedback" />
      </div>

      <div class="form-group">
        <label for="password-register">Senha:</label>
        <Field name="password" type="password" id="password-register" class="form-control" :class="{'is-invalid': errors.password }" />
        <ErrorMessage name="password" class="invalid-feedback" />
      </div>

      <div class="form-group">
        <label for="confirmPassword-register">Confirmar Senha:</label>
        <Field name="confirmPassword" type="password" id="confirmPassword-register" class="form-control" :class="{'is-invalid': errors.confirmPassword }" />
        <ErrorMessage name="confirmPassword" class="invalid-feedback" />
      </div>

      <div v-if="errors.apiError" class="api-error-message form-feedback">
        {{ errors.apiError }}
      </div>
      <div v-else-if="authStore.error && !errors.apiError" class="api-error-message form-feedback">
        {{ authStore.error }}
      </div>

      <button type="submit" :disabled="isSubmitting || authStore.loading" class="btn btn-primary btn-block">
        {{ (isSubmitting || authStore.loading) ? 'Registrando...' : 'Registrar' }}
      </button>
    </Form>
    <p class="form-link-center">
      Já tem uma conta? <router-link to="/login">Faça login</router-link>
    </p>
  </div>
</template>

<style scoped>
.register-view-layout {
  max-width: 480px;
  margin: var(--padding-xl) auto;
}
.register-view-layout h2 {
  text-align: center;
  margin-bottom: var(--padding-lg);
  font-size: 2em;
  color: var(--color-text-primary);
}
.btn-block {
  width: 100%;
  margin-top: var(--padding-md);
}
.form-link-center {
  text-align: center;
  margin-top: var(--padding-lg);
  font-size: 0.9rem;
  font-family: var(--font-sans-ui);
  color: var(--color-text-secondary);
}
.form-link-center a {
  font-weight: 600;
  color: var(--color-text-link);
}
.form-link-center a:hover {
  color: var(--color-text-link-hover);
}
</style>


================================================================================
Capítulo 54: frontend\src\views\RequestPasswordRecoveryView.vue
================================================================================

<script setup lang="ts">
import { ref } from 'vue';
import { useAuthStore } from '@/stores/auth';
import { useRouter } from 'vue-router';
import { Form, Field, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

const authStore = useAuthStore();
const router = useRouter();

const isDev = import.meta.env.DEV;

const validationSchema = yup.object({
  email: yup.string().required('O email é obrigatório').email('Formato de email inválido'),
});

const initialValues = {
  email: '',
};

const successInfoMessage = ref<string | null>(null);

const handleRequestRecovery = async (values: Record<string, any>, { setErrors, resetForm }: any) => {
  successInfoMessage.value = null;
  authStore.setError(null);

  try {
    await authStore.requestPasswordRecovery(values.email);
    successInfoMessage.value = 'Solicitação enviada! Para desenvolvimento, verifique os logs do seu backend para obter o token de recuperação. Você será redirecionado em breve...';
    resetForm();

    if (isDev) {
      setTimeout(() => {
        router.push('/reset-password');
      }, 4000);
    }
  } catch (error: any) {
    if (authStore.error) {
      setErrors({ apiError: authStore.error });
    } else if (error.message) {
      setErrors({ apiError: error.message });
    } else {
      setErrors({ apiError: 'Falha ao solicitar recuperação. Tente novamente.' });
    }
    console.error("FRONTEND (RequestPasswordRecoveryView): Erro na solicitação de recuperação de senha:", error);
  }
};
</script>

<template>
  <div class="view-card-container request-recovery-layout">
    <h2>Esqueci Minha Senha</h2>
    <p class="form-description">
      Insira seu endereço de email. Se uma conta estiver associada, instruções para redefinir
      sua senha serão enviadas (em desenvolvimento, o token aparecerá nos logs do backend).
    </p>
    <Form :validation-schema="validationSchema" :initial-values="initialValues" @submit="handleRequestRecovery"
      v-slot="{ errors, isSubmitting, meta }">
      <div class="form-group">
        <label for="email-recovery">Email:</label>
        <Field name="email" type="email" id="email-recovery" class="form-control" :class="{ 'is-invalid': errors.email }"
          placeholder="seuemail@exemplo.com" />
        <ErrorMessage name="email" class="invalid-feedback" />
      </div>

      <div v-if="successInfoMessage && !errors.apiError" class="info-message form-feedback">
        {{ successInfoMessage }}
      </div>
      <div v-if="errors.apiError" class="api-error-message form-feedback">
        {{ errors.apiError }}
      </div>
      <div v-else-if="authStore.error && !meta.dirty && meta.touched && !errors.apiError"
        class="api-error-message form-feedback">
        {{ authStore.error }}
      </div>

      <button type="submit" :disabled="isSubmitting || authStore.loading || !meta.valid && meta.touched"
        class="btn btn-primary btn-block">
        {{ (isSubmitting || authStore.loading) ? 'Enviando...' : 'Solicitar Recuperação' }}
      </button>
    </Form>
    <hr class="divider" />
    <p class="form-link-center">
      Lembrou sua senha? <router-link to="/login">Faça login</router-link>
    </p>
    <div v-if="isDev" class="dev-instructions">
      <p>
        <strong>Fluxo de Desenvolvimento:</strong>
        Após solicitar, você será redirecionado para a página de redefinição.
        Pegue o token nos logs do seu container backend e cole-o no campo apropriado na próxima tela.
      </p>
    </div>
  </div>
</template>

<style scoped>
.request-recovery-layout {
  max-width: 500px;
  margin: var(--padding-xl) auto;
}

.request-recovery-layout h2 {
  text-align: center;
  margin-bottom: var(--padding-md);
  font-size: 1.8em;
  color: var(--color-text-primary);
}

.form-description {
  text-align: center;
  margin-bottom: var(--padding-lg);
  font-size: 0.95rem;
  color: var(--color-text-secondary);
  font-family: var(--font-sans-ui);
}

.btn-block {
  width: 100%;
  margin-top: var(--padding-md);
}

.form-link-center {
  text-align: center;
  margin-top: var(--padding-lg);
  font-size: 0.9rem;
  font-family: var(--font-sans-ui);
  color: var(--color-text-secondary);
}

.form-link-center a {
  font-weight: 600;
  color: var(--color-text-link);
}

.form-link-center a:hover {
  color: var(--color-text-link-hover);
}

.dev-instructions {
  margin-top: var(--padding-lg);
  padding: var(--padding-md);
  background-color: var(--color-info-bg, #cff4fc);
  /* Usando uma cor de fundo para info */
  border: 1px solid var(--color-info-border, #b6effb);
  /* Borda correspondente */
  color: var(--color-info-text, #055160);
  /* Texto correspondente */
  border-radius: var(--border-radius-md);
  font-size: 0.85em;
  text-align: left;
  font-family: var(--font-sans-ui);
}

.dev-instructions strong {
  font-weight: 600;
  color: var(--color-info-text, #055160);
}

.divider {
  border: 0;
  height: 1px;
  background-color: var(--color-border-subtle);
  margin: var(--padding-lg) 0;
}
</style>


================================================================================
Capítulo 55: frontend\src\views\ResetPasswordView.vue
================================================================================

<script setup lang="ts">
import { ref, onMounted, watch } from 'vue';
import { useRoute } from 'vue-router';
import type { LocationQueryValue } from 'vue-router';
import { useAuthStore } from '@/stores/auth';
import type { PasswordResetForm } from '@/types/user';
import { Form, Field, ErrorMessage } from 'vee-validate';
import * as yup from 'yup';

const route = useRoute();
const authStore = useAuthStore();

const validationSchema = yup.object({
  inputToken: yup.string().required('O token de recuperação é obrigatório'),
  newPassword: yup.string()
    .required('A nova senha é obrigatória')
    .min(8, 'A nova senha deve ter pelo menos 8 caracteres'),
  newPasswordConfirm: yup.string()
    .required('A confirmação da nova senha é obrigatória')
    .oneOf([yup.ref('newPassword')], 'As novas senhas não coincidem'),
});

const formValues = ref({
  inputToken: '',
  newPassword: '',
  newPasswordConfirm: '',
});

const updateTokenFromQuery = (queryParam: LocationQueryValue | LocationQueryValue[] | null | undefined) => {
  let extractedString: string | null = null;

  if (Array.isArray(queryParam)) {
    extractedString = queryParam[0];
  } else if (queryParam !== undefined) {
    extractedString = queryParam;
  }

  if (typeof extractedString === 'string' && extractedString) {
    formValues.value.inputToken = extractedString;
  } else {
    formValues.value.inputToken = '';
  }
};

onMounted(() => {
  updateTokenFromQuery(route.query.token);
});

watch(() => route.query.token, (newToken) => {
  authStore.setError(null);
  updateTokenFromQuery(newToken);
});

const handleResetPassword = async (values: Record<string, any>, { setErrors }: any) => {
  authStore.setError(null);

  const resetData: PasswordResetForm = {
    token: values.inputToken,
    new_password: values.newPassword,
    new_password_confirm: values.newPasswordConfirm,
  };

  try {
    await authStore.resetPassword(resetData);
  } catch (error: any) {
    if (authStore.error) {
      setErrors({ apiError: authStore.error });
    } else if (error.response?.data?.detail) {
      const detail = error.response.data.detail;
      if (typeof detail === 'string') {
        setErrors({ apiError: detail });
      } else if (Array.isArray(detail) && detail[0]?.msg) {
        setErrors({ apiError: detail[0].msg });
      } else {
        setErrors({ apiError: 'Falha ao redefinir a senha.' });
      }
    } else {
      setErrors({ apiError: 'Ocorreu um erro desconhecido ao tentar redefinir a senha.' });
    }
    console.error('Erro ao redefinir senha no componente:', error);
  }
};
</script>

<template>
  <div class="view-card-container reset-password-layout">
    <h2>Redefinir Senha</h2>

    <Form :validation-schema="validationSchema" v-model:values="formValues" @submit="handleResetPassword"
      v-slot="{ errors, isSubmitting, meta }">
      <div class="form-group">
        <label for="inputToken-reset">Token de Recuperação:</label>
        <Field name="inputToken" type="text" id="inputToken-reset" class="form-control"
          :class="{ 'is-invalid': errors.inputToken }" placeholder="Cole o token aqui" />
        <ErrorMessage name="inputToken" class="invalid-feedback" />
        <small v-if="!route.query.token && !formValues.inputToken" class="form-text">
          Cole o token dos logs do backend ou o token recebido por email.
        </small>
      </div>

      <div class="form-group">
        <label for="newPassword-reset">Nova Senha:</label>
        <Field name="newPassword" type="password" id="newPassword-reset" class="form-control"
          :class="{ 'is-invalid': errors.newPassword }" />
        <ErrorMessage name="newPassword" class="invalid-feedback" />
      </div>

      <div class="form-group">
        <label for="newPasswordConfirm-reset">Confirmar Nova Senha:</label>
        <Field name="newPasswordConfirm" type="password" id="newPasswordConfirm-reset" class="form-control"
          :class="{ 'is-invalid': errors.newPasswordConfirm }" />
        <ErrorMessage name="newPasswordConfirm" class="invalid-feedback" />
      </div>

      <div v-if="errors.apiError" class="api-error-message form-feedback">
        {{ errors.apiError }}
      </div>
      <div v-else-if="authStore.error && !meta.dirty && meta.touched && !errors.apiError"
        class="api-error-message form-feedback">
        {{ authStore.error }}
      </div>

      <button type="submit" :disabled="isSubmitting || authStore.loading || !meta.valid && meta.touched"
        class="btn btn-primary btn-block">
        {{ (isSubmitting || authStore.loading) ? 'Redefinindo...' : 'Redefinir Senha' }}
      </button>
    </Form>
    <p v-if="!authStore.isAuthenticated" class="form-link-center">
      Lembrou sua senha? <router-link to="/login">Faça login</router-link>
    </p>
  </div>
</template>

<style scoped>
.reset-password-layout {
  max-width: 480px;
  margin: var(--padding-xl) auto;
}
.reset-password-layout h2 {
  text-align: center;
  margin-bottom: var(--padding-lg);
  font-size: 1.8em;
  color: var(--color-text-primary);
}
.btn-block {
  width: 100%;
  margin-top: var(--padding-md);
}
.form-link-center {
  text-align: center;
  margin-top: var(--padding-lg);
  font-size: 0.9rem;
  font-family: var(--font-sans-ui);
  color: var(--color-text-secondary);
}
.form-link-center a {
  font-weight: 600;
  color: var(--color-text-link);
}
.form-link-center a:hover {
  color: var(--color-text-link-hover);
}
.form-text {
  display: block;
  margin-top: var(--padding-xxs);
  font-size: 0.875em;
  color: var(--color-text-secondary);
}
</style>


================================================================================
Capítulo 56: frontend\src\views\UserProfileView.vue
================================================================================

<script setup lang="ts">
import { ref, onMounted, computed, watch } from 'vue'
import { useAuthStore } from '@/stores/auth'
import type { UserUpdate, UserRead } from '@/types/user'
import { useRouter } from 'vue-router'
import { Form, Field, ErrorMessage } from 'vee-validate'
import * as yup from 'yup'

const authStore = useAuthStore()
const router = useRouter()

const currentUser = computed(() => authStore.currentUser)

const editMode = ref(false)
const successMessage = ref<string | null>(null)
const generalError = ref<string | null>(null);

const validationSchema = yup.object({
  fullName: yup.string().nullable(),
  email: yup.string().required('O email é obrigatório').email('Formato de email inválido'),
})

const formValues = ref({
  fullName: '',
  email: '',
})

const populateForm = () => {
  if (currentUser.value) {
    formValues.value.fullName = currentUser.value.full_name || ''
    formValues.value.email = currentUser.value.email || ''
  }
}

onMounted(() => {
  populateForm()
})

watch(
  currentUser,
  (newUserValue: UserRead | null) => {
    if (newUserValue && !editMode.value) {
      populateForm()
    }
  },
  { immediate: true, deep: true },
)

const toggleEditMode = () => {
  editMode.value = !editMode.value
  authStore.setError(null)
  successMessage.value = null
  generalError.value = null;
  if (editMode.value) {
    populateForm()
  }
}

const handleUpdateProfile = async (values: Record<string, any>, { setErrors }: any) => {
  authStore.setError(null)
  successMessage.value = null
  generalError.value = null;

  if (!currentUser.value) {
    setErrors({ apiError: 'Usuário não encontrado.' })
    return
  }

  const updateData: UserUpdate = {}
  let hasChanges = false

  const currentFullName = currentUser.value.full_name || ''
  const currentEmail = currentUser.value.email

  if (values.fullName !== currentFullName) {
    updateData.full_name = values.fullName.trim() === '' ? null : values.fullName.trim()
    hasChanges = true
  }
  if (values.email !== currentEmail) {
    updateData.email = values.email
    hasChanges = true
  }

  if (!hasChanges) {
    generalError.value = 'Nenhuma alteração detectada.'
    return
  }

  try {
    await authStore.updateUserProfile(updateData)
    successMessage.value = 'Perfil atualizado com sucesso!'
    editMode.value = false
  } catch (error: any) {
    if (authStore.error) {
      setErrors({ apiError: authStore.error })
    } else if (error.response?.data?.detail) {
      const detail = error.response.data.detail
      if (typeof detail === 'string') {
        setErrors({ apiError: detail })
      } else if (Array.isArray(detail) && detail[0]?.msg) {
        setErrors({ apiError: detail[0].msg })
      } else {
        setErrors({ apiError: 'Falha ao atualizar o perfil.' })
      }
    } else {
      setErrors({ apiError: 'Ocorreu um erro desconhecido ao atualizar o perfil.' })
    }
    console.error('Falha ao atualizar perfil no componente:', error)
  }
}

const handleDeleteAccount = async () => {
  if (
    window.confirm('TEM CERTEZA ABSOLUTA que deseja deletar sua conta? Esta ação é irreversível.')
  ) {
    if (window.confirm('SEGUNDA CONFIRMAÇÃO: Deletar conta permanentemente?')) {
      authStore.setError(null)
      successMessage.value = null
      generalError.value = null;
      try {
        await authStore.deleteUserAccount()
      } catch (error) {
        generalError.value = authStore.error || 'Falha ao deletar a conta. Tente novamente.'
        console.error('Falha ao deletar conta no componente:', error)
      }
    }
  }
}

const navigateToChangePassword = () => {
  router.push({ name: 'change-password' })
}
</script>

<template>
  <div class="view-card-container profile-view-layout" v-if="currentUser">
    <h1>Meu Perfil</h1>

    <div v-if="successMessage" class="success-message form-feedback">
      {{ successMessage }}
    </div>
    <div v-if="generalError && !authStore.error" class="error-message form-feedback">
      {{ generalError }}
    </div>
    <div v-if="authStore.error && !successMessage" class="api-error-message form-feedback">
      {{ authStore.error }}
    </div>

    <div v-if="!editMode" class="profile-display">
      <div class="profile-field">
        <span class="profile-field-label">Nome Completo:</span>
        <span class="profile-field-value">{{ currentUser.full_name || 'Não informado' }}</span>
      </div>
      <div class="profile-field">
        <span class="profile-field-label">Email:</span>
        <span class="profile-field-value">{{ currentUser.email }}</span>
      </div>
      <div class="profile-field">
        <span class="profile-field-label">Status:</span>
        <span
          class="profile-field-value"
          :class="currentUser.is_active ? 'status-active' : 'status-inactive'"
        >
          {{ currentUser.is_active ? 'Ativo' : 'Inativo' }}
        </span>
      </div>
      <div class="profile-field" v-if="currentUser.is_superuser">
        <span class="profile-field-label">Nível de Acesso:</span>
        <span class="profile-field-value status-admin">Administrador</span>
      </div>

      <div class="actions-group">
        <button @click="toggleEditMode" class="btn btn-accent">Editar Perfil</button>
        <button @click="navigateToChangePassword" class="btn btn-secondary">Alterar Senha</button>
      </div>
    </div>

    <Form
      v-if="editMode"
      :validation-schema="validationSchema"
      :initial-values="formValues"
      @submit="handleUpdateProfile"
      v-slot="{ errors, isSubmitting, meta }"
      class="profile-edit-form"
    >
      <h3>Editar Informações</h3>
      <div class="form-group">
        <label for="fullName-profile">Nome Completo:</label>
        <Field name="fullName" type="text" id="fullName-profile" class="form-control" />
        <ErrorMessage name="fullName" class="invalid-feedback" />
      </div>
      <div class="form-group">
        <label for="email-profile">Email:</label>
        <Field
          name="email"
          type="email"
          id="email-profile"
          class="form-control"
          :class="{ 'is-invalid': errors.email }"
          required
        />
        <ErrorMessage name="email" class="invalid-feedback" />
      </div>

      <div v-if="errors.apiError" class="api-error-message form-feedback">
        {{ errors.apiError }}
      </div>

      <div class="form-actions">
        <button type="button" @click="toggleEditMode" class="btn btn-secondary">Cancelar</button>
        <button
          type="submit"
          :disabled="isSubmitting || authStore.loading || !meta.dirty"
          class="btn btn-primary"
        >
          {{ isSubmitting || authStore.loading ? 'Salvando...' : 'Salvar Alterações' }}
        </button>
      </div>
    </Form>

    <hr class="divider" />

    <div class="danger-zone">
      <h3>Zona de Perigo</h3>
      <p>Deletar sua conta é uma ação permanente e não pode ser desfeita.</p>
      <button
        @click="handleDeleteAccount"
        class="btn btn-danger"
        :disabled="authStore.loading && editMode"
      >
        {{ authStore.loading && editMode ? 'Aguarde...' : 'Deletar Minha Conta' }}
      </button>
    </div>
  </div>
  <div v-else class="view-card-container loading-profile">
    <p>Carregando informações do perfil ou usuário não autenticado...</p>
  </div>
</template>

<style scoped>
.profile-view-layout {
  max-width: 700px;
  margin: var(--padding-xl) auto;
}
.profile-view-layout h1 {
  text-align: center;
  margin-bottom: var(--padding-xl);
  font-size: 2em;
  color: var(--color-text-primary);
}
.profile-view-layout h3 {
  font-size: 1.5em;
  font-family: var(--font-sans-ui);
  font-weight: 600;
  color: var(--color-text-primary);
  margin-top: var(--padding-lg);
  margin-bottom: var(--padding-md);
  text-align: left;
  padding-bottom: var(--padding-sm);
  border-bottom: 1px solid var(--color-border);
}
.profile-display {
  margin-bottom: var(--padding-xl);
}
.profile-field {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--padding-sm) 0;
  border-bottom: 1px dotted var(--color-border-subtle);
}
.profile-field:last-of-type { 
  border-bottom: none;
}
.profile-field-label {
  font-weight: 600;
  font-family: var(--font-sans-ui);
  color: var(--color-text-secondary);
  margin-right: var(--padding-md);
}
.profile-field-value {
  color: var(--color-text-primary);
  text-align: right;
}
.status-active {
  color: var(--color-success);
  font-weight: 600;
}
.status-inactive {
  color: var(--color-danger);
  font-weight: 600;
}
.status-admin {
  color: var(--color-admin-link-color);
  font-weight: 600;
  background-color: rgba(192, 160, 98, 0.1);
  padding: var(--padding-xxs) var(--padding-xs);
  border-radius: var(--border-radius-sm);
}

.actions-group {
  margin-top: var(--padding-lg);
  display: flex;
  gap: var(--padding-md);
  justify-content: flex-start;
}
.profile-edit-form {
  margin-top: var(--padding-lg);
}
.form-actions {
  margin-top: var(--padding-lg);
  display: flex;
  justify-content: flex-end;
  gap: var(--padding-md);
}
.divider {
  border: 0;
  height: 1px;
  background-color: var(--color-border-subtle);
  margin: var(--padding-xl) 0;
}
.danger-zone {
  padding: var(--padding-lg);
  border: 1px solid var(--color-danger);
  border-radius: var(--border-radius-lg);
  background-color: rgba(244, 67, 54, 0.05);
  margin-top: var(--padding-lg);
}
.danger-zone h3 {
  color: var(--color-danger);
  margin-top: 0;
  font-size: 1.3em;
  border-bottom: none;
  text-align: left;
}
.danger-zone p {
  color: var(--color-danger);
  font-size: 0.95em;
  margin-bottom: var(--padding-md);
}
.danger-zone .btn-danger {
  margin-top: var(--padding-sm);
}
.loading-profile p {
  text-align: center;
  padding: var(--padding-xl);
  font-size: 1.1em;
  color: var(--color-text-secondary);
}
.form-feedback {
  margin-bottom: var(--padding-lg);
}
</style>


================================================================================
Capítulo 57: frontend\src\views\admin\AdminCreateUserView.vue
================================================================================

<script setup lang="ts">
import { computed } from 'vue'
import { useRouter } from 'vue-router'
import { useAdminUsersStore } from '@/stores/adminUsersStore'
import type { UserCreate } from '@/types/user'
import { Form, Field, ErrorMessage } from 'vee-validate'
import * as yup from 'yup'

const router = useRouter()
const adminUsersStore = useAdminUsersStore()

const isSubmittingForm = computed(() => adminUsersStore.isLoading)

const validationSchema = yup.object({
  email: yup.string().required('O email é obrigatório').email('Formato de email inválido'),
  full_name: yup.string().nullable(),
  password: yup
    .string()
    .required('A senha é obrigatória')
    .min(8, 'A senha deve ter pelo menos 8 caracteres'),
  confirmPassword: yup
    .string()
    .required('A confirmação de senha é obrigatória')
    .oneOf([yup.ref('password')], 'As senhas não coincidem'),
  is_active: yup.boolean(),
  is_superuser: yup.boolean(),
})

const initialValues = {
  email: '',
  full_name: '',
  password: '',
  confirmPassword: '',
  is_active: true,
  is_superuser: false,
}

const handleCreateUserByAdmin = async (
  values: Record<string, any>,
  { setErrors, resetForm }: any,
) => {
  adminUsersStore._setError(null)

  const createData: UserCreate = {
    email: values.email,
    password: values.password,
    full_name: values.full_name === '' ? null : values.full_name,
    is_active: values.is_active,
    is_superuser: values.is_superuser,
  }

  try {
    await adminUsersStore.createUserByAdmin(createData)
    resetForm()
    router.push({ name: 'admin-users' })
  } catch (err: any) {
    const errorMessage = adminUsersStore.usersError || 'Falha ao criar usuário.'
    setErrors({ apiError: errorMessage })
    console.error('Erro ao criar usuário (admin) no componente:', err)
  }
}

const goBackToList = () => {
  adminUsersStore._setError(null)
  router.push({ name: 'admin-users' })
}
</script>

<template>
  <div class="view-card-container admin-create-user-layout">
    <header class="page-header-alt">
      <h1>Criar Novo Usuário <span class="admin-tag">(Admin)</span></h1>
      <button @click="goBackToList" class="btn btn-secondary btn-small">Voltar para Lista</button>
    </header>

    <Form
      :validation-schema="validationSchema"
      :initial-values="initialValues"
      @submit="handleCreateUserByAdmin"
      v-slot="{ errors, isSubmitting, meta }"
      class="create-user-form"
    >
      <div class="form-row">
        <div class="form-group">
          <label for="email-admin-create">Email:</label>
          <Field
            name="email"
            type="email"
            id="email-admin-create"
            class="form-control"
            :class="{ 'is-invalid': errors.email }"
          />
          <ErrorMessage name="email" class="invalid-feedback" />
        </div>
        <div class="form-group">
          <label for="fullName-admin-create">Nome Completo:</label>
          <Field
            name="full_name"
            type="text"
            id="fullName-admin-create"
            class="form-control"
            :class="{ 'is-invalid': errors.full_name }"
          />
          <ErrorMessage name="full_name" class="invalid-feedback" />
        </div>
      </div>

      <div class="form-row">
        <div class="form-group">
          <label for="password-admin-create">Senha:</label>
          <Field
            name="password"
            type="password"
            id="password-admin-create"
            class="form-control"
            :class="{ 'is-invalid': errors.password }"
          />
          <ErrorMessage name="password" class="invalid-feedback" />
        </div>
        <div class="form-group">
          <label for="confirmPassword-admin-create">Confirmar Senha:</label>
          <Field
            name="confirmPassword"
            type="password"
            id="confirmPassword-admin-create"
            class="form-control"
            :class="{ 'is-invalid': errors.confirmPassword }"
          />
          <ErrorMessage name="confirmPassword" class="invalid-feedback" />
        </div>
      </div>

      <div class="form-row form-row-checkboxes">
        <div class="form-group form-group-checkbox">
          <Field
            name="is_active"
            type="checkbox"
            id="isActive-admin-create"
            class="form-check-input"
            :value="true"
            checked
          />
          <label for="isActive-admin-create" class="form-check-label">Usuário Ativo</label>
        </div>
        <div class="form-group form-group-checkbox">
          <Field
            name="is_superuser"
            type="checkbox"
            id="isSuperuser-admin-create"
            class="form-check-input"
            :value="true"
          />
          <label for="isSuperuser-admin-create" class="form-check-label">É Superusuário</label>
        </div>
      </div>

      <div v-if="errors.apiError" class="api-error-message form-feedback">
        {{ errors.apiError }}
      </div>
      <div
        v-else-if="adminUsersStore.usersError && !errors.apiError"
        class="api-error-message form-feedback"
      >
        {{ adminUsersStore.usersError }}
      </div>

      <div class="form-actions">
        <button type="button" @click="goBackToList" class="btn btn-secondary">Cancelar</button>
        <button
          type="submit"
          :disabled="isSubmittingForm || (meta.touched && !meta.valid)"
          class="btn btn-primary"
        >
          {{ isSubmittingForm ? 'Criando...' : 'Criar Usuário' }}
        </button>
      </div>
    </Form>
  </div>
</template>

<style scoped>
.admin-create-user-layout {
  max-width: 700px;
  margin: var(--padding-xl) auto;
}
.page-header-alt {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--padding-lg);
  padding-bottom: var(--padding-md);
  border-bottom: 1px solid var(--color-border);
}
.page-header-alt h1 {
  font-size: 1.6em;
  color: var(--color-text-primary);
  margin: 0;
}
.admin-tag {
  font-size: 0.8em;
  color: var(--color-text-secondary);
  font-weight: normal;
}
.create-user-form {
  margin-top: var(--padding-md);
}
.form-row {
  display: flex;
  flex-direction: column;
  gap: 0;
  margin-bottom: 0;
}
.form-group {
  margin-bottom: var(--padding-lg);
  flex: 1;
}
.form-row .form-group {
  margin-bottom: var(--padding-lg);
}
.form-group-checkbox {
  display: flex; 
  align-items: center;
  margin-bottom: var(--padding-sm); 
}
.form-group-checkbox .form-check-input {
  margin-top: 0; 
}
.form-row-checkboxes { 
  align-items: center;
}
.form-actions {
  margin-top: var(--padding-lg);
  display: flex;
  justify-content: flex-end;
  gap: var(--padding-md);
}
@media (min-width: 768px) {
  .form-row {
    flex-direction: row;
    gap: var(--padding-lg);
  }
  .form-row-checkboxes .form-group-checkbox {
    margin-bottom: var(--padding-lg); 
  }
}
</style>


================================================================================
Capítulo 58: frontend\src\views\admin\AdminEditUsersView.vue
================================================================================

<script setup lang="ts">
import { ref, onMounted, computed, watch } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useAdminUsersStore } from '@/stores/adminUsersStore'
import type { UserUpdate, UserRead } from '@/types/user'
import { Form, Field, ErrorMessage } from 'vee-validate'
import * as yup from 'yup'

const route = useRoute()
const router = useRouter()
const adminUsersStore = useAdminUsersStore()

const userId = computed(() => Number(route.params.id))
const userForEdit = computed(() => adminUsersStore.userForEdit)
const isLoadingData = computed(() => adminUsersStore.isLoadingUserForEdit)
const isSubmittingForm = computed(() => adminUsersStore.isLoading)
const errorLoadingUser = computed(() => adminUsersStore.userForEditError)

const validationSchema = yup.object({
  email: yup.string().required('O email é obrigatório').email('Formato de email inválido'),
  full_name: yup.string().nullable(),
  is_active: yup.boolean(),
  is_superuser: yup.boolean(),
  password: yup
    .string()
    .optional()
    .test(
      'min-length-if-provided',
      'A nova senha deve ter pelo menos 8 caracteres (se fornecida)',
      (value) => !value || value.length === 0 || value.length >= 8,
    ),
})

interface EditFormShape {
  email: string
  full_name: string | null
  is_active: boolean
  is_superuser: boolean
  password?: string
}

const formValues = ref<EditFormShape>({
  email: '',
  full_name: null,
  is_active: true,
  is_superuser: false,
  password: '',
})

watch(
  userForEdit,
  (currentUser: UserRead | null) => {
    if (currentUser) {
      formValues.value = {
        email: currentUser.email,
        full_name: currentUser.full_name || null,
        is_active: currentUser.is_active,
        is_superuser: currentUser.is_superuser,
        password: '',
      }
    } else {
      formValues.value = {
        email: '',
        full_name: null,
        is_active: true,
        is_superuser: false,
        password: '',
      }
    }
  },
  { immediate: true },
)

onMounted(async () => {
  adminUsersStore._setError(null)
  adminUsersStore._setSingleUserError(null)
  if (userId.value && !isNaN(userId.value)) {
    await adminUsersStore.fetchUserById(userId.value)
  } else {
    adminUsersStore._setSingleUserError('ID de usuário inválido na rota.')
    router.push({ name: 'admin-users' })
  }
})

const handleUpdateUserByAdmin = async (values: Record<string, any>, { setErrors }: any) => {
  adminUsersStore._setError(null)

  if (!userForEdit.value || !userId.value || isNaN(userId.value)) {
    setErrors({ apiError: 'Não há dados do usuário ou ID inválido para atualizar.' })
    return
  }

  const updatePayload: UserUpdate = {}
  let hasChanges = false

  const originalUser = userForEdit.value

  if (values.email !== undefined && values.email !== originalUser.email) {
    updatePayload.email = values.email as string
    hasChanges = true
  }

  const currentFullName = originalUser.full_name || null
  const formFullName = values.full_name === '' ? null : (values.full_name as string | null)
  if (values.full_name !== undefined && formFullName !== currentFullName) {
    updatePayload.full_name = formFullName
    hasChanges = true
  }

  if (typeof values.is_active === 'boolean' && values.is_active !== originalUser.is_active) {
    updatePayload.is_active = values.is_active
    hasChanges = true
  }

  if (
    typeof values.is_superuser === 'boolean' &&
    values.is_superuser !== originalUser.is_superuser
  ) {
    updatePayload.is_superuser = values.is_superuser
    hasChanges = true
  }

  if (values.password && (values.password as string).trim() !== '') {
    updatePayload.password = values.password as string
    hasChanges = true
  }

  if (!hasChanges) {
    setErrors({ apiError: 'Nenhuma alteração para salvar.' })
    return
  }

  try {
    await adminUsersStore.updateUserByAdmin(userId.value, updatePayload)
    router.push({ name: 'admin-users' })
  } catch (err: any) {
    const errorMessageFromStore = adminUsersStore.usersError || adminUsersStore.userForEditError
    setErrors({ apiError: errorMessageFromStore || 'Falha ao atualizar usuário.' })
    console.error('Erro ao atualizar usuário (admin) no componente:', err)
  }
}

const goBackToList = () => {
  adminUsersStore._setCurrentUserForEdit(null)
  adminUsersStore._setSingleUserError(null)
  adminUsersStore._setError(null)
  router.push({ name: 'admin-users' })
}
</script>

<template>
  <div class="view-card-container admin-edit-user-layout">
    <header class="page-header-alt">
      <h1>
        {{ userForEdit ? `Editar Usuário: ${userForEdit.email}` : 'Editar Usuário' }}
        <span class="admin-tag">(Admin)</span>
      </h1>
      <button @click="goBackToList" class="btn btn-secondary btn-small">Voltar para Lista</button>
    </header>

    <div v-if="isLoadingData" class="loading-indicator form-feedback">
      <p>Carregando dados do usuário...</p>
    </div>
    <div v-else-if="errorLoadingUser && !userForEdit" class="api-error-message form-feedback">
      <p>{{ errorLoadingUser }}</p>
    </div>
    <div v-else-if="!userForEdit && !isLoadingData" class="api-error-message form-feedback">
      <p>Usuário não encontrado ou ID inválido.</p>
    </div>

    <Form
      v-if="userForEdit && !isLoadingData"
      :validation-schema="validationSchema"
      v-model:values="formValues"
      @submit="handleUpdateUserByAdmin"
      v-slot="{ errors, isSubmitting, meta }"
      enable-reinitialize
      class="edit-user-form"
    >
      <div class="form-row">
        <div class="form-group">
          <label for="email-admin-edit">Email:</label>
          <Field
            name="email"
            type="email"
            id="email-admin-edit"
            class="form-control"
            :class="{ 'is-invalid': errors.email }"
          />
          <ErrorMessage name="email" class="invalid-feedback" />
        </div>
        <div class="form-group">
          <label for="fullName-admin-edit">Nome Completo:</label>
          <Field
            name="full_name"
            type="text"
            id="fullName-admin-edit"
            class="form-control"
            :class="{ 'is-invalid': errors.full_name }"
          />
          <ErrorMessage name="full_name" class="invalid-feedback" />
        </div>
      </div>

      <div class="form-row form-row-checkboxes">
        <div class="form-group form-group-checkbox">
          <Field
            name="is_active"
            type="checkbox"
            id="isActive-admin-edit"
            class="form-check-input"
            v-model="formValues.is_active"
            :value="true"
            :unchecked-value="false"
          />
          <label for="isActive-admin-edit" class="form-check-label">Usuário Ativo</label>
        </div>
        <div class="form-group form-group-checkbox">
          <Field
            name="is_superuser"
            type="checkbox"
            id="isSuperuser-admin-edit"
            class="form-check-input"
            v-model="formValues.is_superuser"
            :value="true"
            :unchecked-value="false"
          />
          <label for="isSuperuser-admin-edit" class="form-check-label">É Superusuário</label>
        </div>
      </div>

      <div class="form-group">
        <label for="password-admin-edit">Nova Senha (opcional):</label>
        <Field
          name="password"
          type="password"
          id="password-admin-edit"
          class="form-control"
          :class="{ 'is-invalid': errors.password }"
          placeholder="Deixe em branco para não alterar"
        />
        <ErrorMessage name="password" class="invalid-feedback" />
        <small class="form-text">Preencha apenas se desejar alterar a senha deste usuário.</small>
      </div>

      <div v-if="errors.apiError" class="api-error-message form-feedback">
        {{ errors.apiError }}
      </div>
      <div
        v-else-if="adminUsersStore.usersError && !errors.apiError"
        class="api-error-message form-feedback"
      >
        {{ adminUsersStore.usersError }}
      </div>

      <div class="form-actions">
        <button type="button" @click="goBackToList" class="btn btn-secondary">Cancelar</button>
        <button type="submit" :disabled="isSubmittingForm || !meta.dirty" class="btn btn-primary">
          {{ isSubmittingForm ? 'Salvando...' : 'Salvar Alterações' }}
        </button>
      </div>
    </Form>
  </div>
</template>

<style scoped>
.admin-edit-user-layout {
  max-width: 700px;
  margin: var(--padding-xl) auto;
}
.page-header-alt {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--padding-lg);
  padding-bottom: var(--padding-md);
  border-bottom: 1px solid var(--color-border);
}
.page-header-alt h1 {
  font-size: 1.6em;
  color: var(--color-text-primary);
  margin: 0;
}
.admin-tag {
  font-size: 0.8em;
  color: var(--color-text-secondary);
  font-weight: normal;
}
.edit-user-form {
  margin-top: var(--padding-md);
}
.form-row {
  display: flex;
  flex-direction: column;
  gap: 0;
  margin-bottom: 0;
}
.form-group {
  margin-bottom: var(--padding-lg);
  flex: 1;
}
.form-row .form-group {
  margin-bottom: var(--padding-lg);
}
.form-group-checkbox {
  display: flex;
  align-items: center;
  margin-bottom: var(--padding-sm);
}
.form-group-checkbox .form-check-input {
  margin-top: 0;
}
.form-row-checkboxes {
  align-items: center;
}
.form-text {
  display: block;
  margin-top: var(--padding-xxs);
  font-size: 0.875em;
  color: var(--color-text-secondary);
}
.form-actions {
  margin-top: var(--padding-lg);
  display: flex;
  justify-content: flex-end;
  gap: var(--padding-md);
}
@media (min-width: 768px) {
  .form-row {
    flex-direction: row;
    gap: var(--padding-lg);
  }
  .form-row-checkboxes .form-group-checkbox {
    margin-bottom: var(--padding-lg);
  }
}
</style>


================================================================================
Capítulo 59: frontend\src\views\admin\AdminUsersListView.vue
================================================================================

<script setup lang="ts">
import { onMounted, computed } from 'vue'
import { useAuthStore } from '@/stores/auth'
import { useAdminUsersStore } from '@/stores/adminUsersStore'
import { useToast } from 'vue-toastification'
import { useRouter } from 'vue-router'

const toast = useToast()
const authStore = useAuthStore()
const adminUsersStore = useAdminUsersStore()
const router = useRouter()

const users = computed(() => adminUsersStore.allUsers)
const isLoading = computed(() => adminUsersStore.isLoadingUsers)
const error = computed(() => adminUsersStore.usersError)

onMounted(() => {
  adminUsersStore.fetchUsers()
})

const handleEditUser = (userId: number) => {
  router.push({ name: 'admin-edit-user', params: { id: userId.toString() } })
}

const handleDeleteUser = async (userId: number) => {
  const userToDelete = users.value.find((u) => u.id === userId)
  const userDescription = userToDelete ? `(${userToDelete.email})` : `com ID ${userId}`

  if (authStore.currentUser && authStore.currentUser.id === userId) {
    toast.error(
      'Administradores não podem deletar a própria conta através deste painel. Use a página de perfil.',
    )
    return
  }

  if (
    window.confirm(
      `Tem certeza que deseja deletar o usuário ${userDescription}? Esta ação é irreversível.`,
    )
  ) {
    await adminUsersStore.deleteUser(userId)
  }
}
</script>

<template>
  <div class="view-card-container admin-users-list-layout">
    <header class="view-header">
      <h1>Painel de Administração - Usuários</h1>
      <p v-if="authStore.currentUser" class="subtitle">
        Logado como: {{ authStore.currentUser.email }} ({{
          authStore.currentUser.is_superuser ? 'Superuser' : 'Usuário Comum'
        }})
      </p>
    </header>

    <div class="content-area">
      <div v-if="isLoading && users.length === 0" class="loading-indicator form-feedback">
        <p>Carregando usuários...</p>
      </div>
      <div v-else-if="error" class="error-message form-feedback">
        <p>{{ error }}</p>
      </div>
      <div v-else-if="users.length === 0 && !isLoading" class="info-message form-feedback">
        <p>Nenhum usuário encontrado.</p>
      </div>
      <div v-else class="users-table-wrapper">
        <table class="data-table">
          <thead>
            <tr>
              <th>ID</th>
              <th>Email</th>
              <th>Nome Completo</th>
              <th>Ativo</th>
              <th>Superuser</th>
              <th>Ações</th>
            </tr>
          </thead>
          <tbody>
            <tr v-for="user in users" :key="user.id">
              <td>{{ user.id }}</td>
              <td>{{ user.email }}</td>
              <td>{{ user.full_name || 'N/A' }}</td>
              <td>
                <span :class="user.is_active ? 'status-active' : 'status-inactive'">
                  {{ user.is_active ? 'Sim' : 'Não' }}
                </span>
              </td>
              <td>
                <span :class="user.is_superuser ? 'status-admin' : 'status-normal'">
                  {{ user.is_superuser ? 'Sim' : 'Não' }}
                </span>
              </td>
              <td class="actions-cell">
                <button
                  @click="handleEditUser(user.id)"
                  class="btn btn-small btn-accent"
                  :disabled="isLoading"
                >
                  Editar
                </button>
                <button
                  @click="handleDeleteUser(user.id)"
                  class="btn btn-small btn-danger"
                  :disabled="isLoading"
                >
                  Deletar
                </button>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <div class="view-actions-footer">
        <RouterLink :to="{ name: 'admin-create-user' }" class="btn btn-primary"
          >Criar Novo Usuário</RouterLink
        >
        <button
          @click="adminUsersStore.fetchUsers()"
          :disabled="isLoading"
          class="btn btn-secondary"
        >
          {{ isLoading ? 'Atualizando...' : 'Atualizar Lista' }}
        </button>
      </div>
    </div>
  </div>
</template>

<style scoped>
.admin-users-list-layout {
  max-width: 1000px;
  margin: var(--padding-xl) auto;
}
.view-header {
  margin-bottom: var(--padding-lg);
  padding-bottom: var(--padding-md);
  border-bottom: 1px solid var(--color-border);
}
.view-header h1 {
  font-size: 1.8em;
  margin-bottom: var(--padding-xs);
  color: var(--color-text-primary);
}
.subtitle {
  font-size: 0.9em;
  color: var(--color-text-secondary);
  font-family: var(--font-sans-ui);
}

.content-area {
  margin-top: var(--padding-md);
}
.users-table-wrapper {
  overflow-x: auto;
}
.data-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: var(--padding-md);
  font-size: 0.9rem;
  font-family: var(--font-sans-ui);
}
.data-table th,
.data-table td {
  border: 1px solid var(--color-border);
  padding: var(--padding-sm) var(--padding-md);
  text-align: left;
  vertical-align: middle;
}
.data-table th {
  background-color: var(--color-bg-hover-subtle);
  font-weight: 600;
  color: var(--color-text-primary);
}
.data-table tbody tr:nth-child(even) {
  background-color: var(--color-bg-light);
}
.data-table tbody tr:hover {
  background-color: var(--color-bg-hover-subtle);
}

.status-active {
  color: var(--color-success);
  font-weight: 600;
}
.status-inactive {
  color: var(--color-danger);
  font-weight: 600;
}
.status-admin {
  color: var(--color-admin-link-color);
  font-weight: 600;
  background-color: rgba(192, 160, 98, 0.1);
  padding: var(--padding-xxs) var(--padding-xs);
  border-radius: var(--border-radius-sm);
  display: inline-block; 
}
.status-normal {
  color: var(--color-text-secondary);
}

.actions-cell {
  white-space: nowrap;
  width: 1%;
  text-align: center;
}
.btn-small {
  padding: var(--padding-xs) var(--padding-sm);
  font-size: 0.85em;
  margin: 0 var(--padding-xxs); 
}
.view-actions-footer {
  margin-top: var(--padding-lg);
  display: flex;
  justify-content: flex-end;
  gap: var(--padding-md);
  border-top: 1px solid var(--color-border);
  padding-top: var(--padding-lg);
}
</style>


================================================================================
Capítulo 60: frontend\vite.config.ts
================================================================================

import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueDevTools from 'vite-plugin-vue-devtools'

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    vueDevTools(),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    },
  },
})


